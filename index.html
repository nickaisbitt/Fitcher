<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fitcher - AI-Powered Crypto Trading</title>
    <meta name="description" content="Modern Nordic-inspired AI trading bot with multi-exchange support">
    <meta name="theme-color" content="#0D1B2A">

    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="favicon.svg">

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        nordic: {
                            dark: '#0D1B2A',
                            deep: '#1B2838',
                            blue: '#4A90B8',
                            pale: '#7FB3D3',
                            ice: '#B8D4E8',
                            frost: '#E8F4FC',
                            white: '#FFFFFF'
                        }
                    }
                }
            }
        }
    </script>

    <!-- React 18 -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>

    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        * { box-sizing: border-box; }
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #0D1B2A 0%, #1B2838 50%, #0D1B2A 100%);
            min-height: 100vh;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }
        #root { min-height: 100vh; }

        /* Custom scrollbar - Nordic theme */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #1B2838; }
        ::-webkit-scrollbar-thumb { background: #4A90B8; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #7FB3D3; }

        /* Animations */
        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 0 5px rgba(127, 179, 211, 0.5); }
            50% { box-shadow: 0 0 20px rgba(127, 179, 211, 0.8); }
        }
        .pulse-glow { animation: pulse-glow 2s infinite; }

        @keyframes slide-in {
            from { transform: translateX(-100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        .slide-in { animation: slide-in 0.3s ease-out; }

        @keyframes frost-shimmer {
            0% { background-position: -200% center; }
            100% { background-position: 200% center; }
        }
        .frost-shimmer {
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            background-size: 200% 100%;
            animation: frost-shimmer 3s infinite;
        }

        /* Loading spinner - Nordic blue */
        .loading-spinner {
            border: 3px solid rgba(127, 179, 211, 0.2);
            border-top: 3px solid #7FB3D3;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Fitcher logo text */
        .fitcher-logo {
            font-weight: 700;
            font-size: 28px;
            background: linear-gradient(135deg, #FFFFFF 0%, #B8D4E8 50%, #7FB3D3 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: -0.5px;
        }
    </style>
</head>
<body>
    <div id="root">
        <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; color: white;">
            <img src="logo.svg" alt="Fitcher" width="80" height="80" style="margin-bottom: 16px;">
            <div class="loading-spinner"></div>
            <p class="fitcher-logo" style="margin-top: 20px;">Fitcher</p>
            <p style="margin-top: 8px; font-size: 14px; color: #7FB3D3;">AI-Powered Trading</p>
            <p style="margin-top: 16px; font-size: 12px; color: #4A90B8;">Initializing...</p>
        </div>
    </div>

    <script type="text/babel">
        // Make React hooks available globally
        const { useState, useEffect, useCallback, useRef } = React;

        // ==================== FITCHER AI TRADING BOT ====================


// ==================== CONSTANTS ====================
const TRADING_PAIRS = [
  'BTC/USD', 'ETH/USD', 'SOL/USD', 'XRP/USD', 'DOGE/USD', 'ADA/USD', 'AVAX/USD',
  'DOT/USD', 'MATIC/USD', 'LINK/USD', 'ATOM/USD', 'UNI/USD', 'LTC/USD', 'BCH/USD',
  'ALGO/USD', 'XLM/USD', 'NEAR/USD', 'FTM/USD', 'SAND/USD', 'MANA/USD', 'AXS/USD',
  'AAVE/USD', 'MKR/USD', 'SNX/USD', 'SUSHI/USD', 'ENJ/USD', 'BAT/USD', 'EOS/USD',
  'XTZ/USD', 'FIL/USD', 'ETC/USD', 'SHIB/USD', 'APE/USD', 'GRT/USD', 'ARB/USD',
  'OP/USD', 'INJ/USD', 'SUI/USD', 'SEI/USD', 'PEPE/USD', 'RENDER/USD', 'FET/USD'
];

const KRAKEN_PAIRS = {
  'BTC/USD': 'XXBTZUSD', 'ETH/USD': 'XETHZUSD', 'SOL/USD': 'SOLUSD', 'XRP/USD': 'XXRPZUSD',
  'DOGE/USD': 'XDGUSD', 'ADA/USD': 'ADAUSD', 'AVAX/USD': 'AVAXUSD', 'DOT/USD': 'DOTUSD',
  'MATIC/USD': 'MATICUSD', 'LINK/USD': 'LINKUSD', 'ATOM/USD': 'ATOMUSD', 'UNI/USD': 'UNIUSD',
  'LTC/USD': 'XLTCZUSD', 'ALGO/USD': 'ALGOUSD', 'XLM/USD': 'XXLMZUSD', 'NEAR/USD': 'NEARUSD',
  'SAND/USD': 'SANDUSD', 'MANA/USD': 'MANAUSD', 'AAVE/USD': 'AAVEUSD', 'SHIB/USD': 'SHIBUSD',
  'APE/USD': 'APEUSD', 'ARB/USD': 'ARBUSD', 'OP/USD': 'OPUSD', 'INJ/USD': 'INJUSD',
  'SUI/USD': 'SUIUSD', 'PEPE/USD': 'PEPEUSD', 'FET/USD': 'FETUSD', 'RENDER/USD': 'RENDERUSD'
};

// Multi-Exchange Configuration
const EXCHANGES = {
  kraken: {
    name: 'Kraken',
    icon: 'ðŸ¦‘',
    wsUrl: 'wss://ws.kraken.com',
    restUrl: 'https://api.kraken.com',
    color: 'purple'
  },
  binance: {
    name: 'Binance',
    icon: 'ðŸŸ¡',
    wsUrl: 'wss://stream.binance.com:9443/ws',
    restUrl: 'https://api.binance.com',
    color: 'amber'
  },
  coinbase: {
    name: 'Coinbase',
    icon: 'ðŸ”µ',
    wsUrl: 'wss://ws-feed.exchange.coinbase.com',
    restUrl: 'https://api.exchange.coinbase.com',
    color: 'blue'
  }
};

// Binance symbol conversion
const toBinanceSymbol = (pair) => pair.replace('/', '').toLowerCase();
const toCoinbaseSymbol = (pair) => pair.replace('/', '-');

const STRATEGIES = {
  momentum: { name: 'Momentum', desc: 'Buy when price rising fast', icon: 'ðŸ“ˆ' },
  meanReversion: { name: 'Mean Reversion', desc: 'Buy dips, sell peaks', icon: 'ðŸ”„' },
  grid: { name: 'Grid Trading', desc: 'Buy/sell at price levels', icon: 'ðŸ“Š' },
  dca: { name: 'DCA', desc: 'Dollar cost average over time', icon: 'ðŸ’°' },
  rsi: { name: 'RSI', desc: 'Oversold/overbought signals', icon: 'ðŸ“‰' },
  macd: { name: 'MACD', desc: 'Moving average crossovers', icon: 'ã€°ï¸' },
  scalp: { name: 'Scalping', desc: 'Quick small profits', icon: 'âš¡' }
};

const TIMEFRAMES = {
  '1m': { minutes: 1, interval: 1 },
  '5m': { minutes: 5, interval: 5 },
  '15m': { minutes: 15, interval: 15 },
  '1h': { minutes: 60, interval: 60 },
  '4h': { minutes: 240, interval: 240 },
  '1d': { minutes: 1440, interval: 1440 }
};

const STRATEGY_PRESETS = {
  conservative: { name: 'Conservative', stopLoss: 2, takeProfit: 3, tradeSize: 10, strategy: 'dca', desc: 'Low risk, steady gains' },
  moderate: { name: 'Moderate', stopLoss: 3, takeProfit: 5, tradeSize: 20, strategy: 'rsi', desc: 'Balanced approach' },
  aggressive: { name: 'Aggressive', stopLoss: 5, takeProfit: 10, tradeSize: 30, strategy: 'momentum', desc: 'Higher risk/reward' },
  gridBot: { name: 'Grid Master', stopLoss: 1, takeProfit: 2, tradeSize: 15, strategy: 'grid', desc: 'Sideways market' },
  scalper: { name: 'Scalper', stopLoss: 1, takeProfit: 1.5, tradeSize: 50, strategy: 'scalp', desc: 'Quick trades' }
};

const BASE_PRICES = {
  'BTC/USD': 97500, 'ETH/USD': 3450, 'SOL/USD': 185, 'XRP/USD': 2.42,
  'DOGE/USD': 0.32, 'ADA/USD': 0.95, 'AVAX/USD': 35, 'DOT/USD': 7.2,
  'MATIC/USD': 0.58, 'LINK/USD': 22, 'ATOM/USD': 8.9, 'UNI/USD': 13,
  'LTC/USD': 104, 'ALGO/USD': 0.38, 'XLM/USD': 0.41, 'NEAR/USD': 5.2,
  'SAND/USD': 0.55, 'MANA/USD': 0.52, 'AAVE/USD': 290, 'SHIB/USD': 0.000022,
  'APE/USD': 1.25, 'ARB/USD': 0.72, 'OP/USD': 1.65, 'INJ/USD': 22,
  'SUI/USD': 4.2, 'PEPE/USD': 0.000018, 'FET/USD': 1.45, 'RENDER/USD': 7.1
};

// ==================== UTILITY FUNCTIONS ====================
const formatPrice = (price, pair) => {
  if (!price || isNaN(price)) return '0.00';
  const smallCoins = ['SHIB', 'PEPE', 'BONK', 'WIF'];
  const isSmall = smallCoins.some(c => pair?.includes(c));
  if (isSmall) return price.toFixed(8);
  if (price < 0.01) return price.toFixed(6);
  if (price < 1) return price.toFixed(4);
  return price.toFixed(2);
};

const formatNumber = (num, decimals = 2) => {
  if (num === undefined || num === null || isNaN(num)) return '0';
  return num.toLocaleString(undefined, { minimumFractionDigits: decimals, maximumFractionDigits: decimals });
};

const formatPercent = (num) => {
  if (!num || isNaN(num)) return '0.00%';
  const sign = num >= 0 ? '+' : '';
  return `${sign}${num.toFixed(2)}%`;
};

// ==================== TECHNICAL INDICATORS ====================
const calculateSMA = (prices, period) => {
  if (!prices || prices.length < period) return prices?.[prices.length - 1] || 0;
  return prices.slice(-period).reduce((a, b) => a + b, 0) / period;
};

const calculateEMA = (prices, period) => {
  if (!prices || prices.length < period) return null;
  const k = 2 / (period + 1);
  let ema = prices.slice(0, period).reduce((a, b) => a + b, 0) / period;
  for (let i = period; i < prices.length; i++) {
    ema = prices[i] * k + ema * (1 - k);
  }
  return ema;
};

const calculateRSI = (prices, period = 14) => {
  if (!prices || prices.length < period + 1) return 50;
  let gains = 0, losses = 0;
  for (let i = prices.length - period; i < prices.length; i++) {
    const diff = prices[i] - prices[i - 1];
    if (diff > 0) gains += diff;
    else losses -= diff;
  }
  const avgGain = gains / period;
  const avgLoss = losses / period;
  if (avgLoss === 0) return 100;
  const rs = avgGain / avgLoss;
  return 100 - (100 / (1 + rs));
};

const calculateMACD = (prices, fast = 12, slow = 26, signalPeriod = 9) => {
  if (!prices || prices.length < slow + signalPeriod) return { macd: 0, signal: 0, histogram: 0, trend: 'neutral' };

  // Calculate MACD line history for proper signal line EMA
  const macdHistory = [];
  for (let i = slow; i <= prices.length; i++) {
    const slice = prices.slice(0, i);
    const ema12 = calculateEMA(slice, fast);
    const ema26 = calculateEMA(slice, slow);
    if (ema12 !== null && ema26 !== null) {
      macdHistory.push(ema12 - ema26);
    }
  }

  // Signal line is 9-period EMA of MACD line (PROPER calculation)
  const signalLine = macdHistory.length >= signalPeriod ? calculateEMA(macdHistory, signalPeriod) : macdHistory[macdHistory.length - 1];
  const macdLine = macdHistory[macdHistory.length - 1] || 0;
  const histogram = macdLine - signalLine;

  // Trend detection
  const prevHistogram = macdHistory.length > 1 ? macdHistory[macdHistory.length - 2] - (signalLine * 0.95) : 0;
  const trend = histogram > 0 && histogram > prevHistogram ? 'bullish' :
                histogram < 0 && histogram < prevHistogram ? 'bearish' : 'neutral';

  return { macd: macdLine, signal: signalLine, histogram, trend };
};

const calculateBollingerBands = (prices, period = 20, stdDev = 2) => {
  if (!prices || prices.length < period) return { upper: 0, middle: 0, lower: 0 };
  const slice = prices.slice(-period);
  const sma = slice.reduce((a, b) => a + b, 0) / period;
  const variance = slice.reduce((sum, val) => sum + Math.pow(val - sma, 2), 0) / period;
  const std = Math.sqrt(variance);
  return { upper: sma + stdDev * std, middle: sma, lower: sma - stdDev * std };
};

// ==================== ADX & ATR INDICATORS ====================
const calculateTrueRange = (high, low, prevClose) => {
  return Math.max(high - low, Math.abs(high - prevClose), Math.abs(low - prevClose));
};

const calculateATR = (ohlcData, period = 14) => {
  if (!ohlcData || ohlcData.length < period + 1) return 0;
  let atr = 0;
  for (let i = 1; i <= period; i++) {
    const tr = calculateTrueRange(ohlcData[i].high, ohlcData[i].low, ohlcData[i - 1].close);
    atr += tr;
  }
  atr /= period;
  for (let i = period + 1; i < ohlcData.length; i++) {
    const tr = calculateTrueRange(ohlcData[i].high, ohlcData[i].low, ohlcData[i - 1].close);
    atr = (atr * (period - 1) + tr) / period;
  }
  return atr;
};

const calculateADX = (ohlcData, period = 14) => {
  if (!ohlcData || ohlcData.length < period * 2) return 25;
  let plusDM = 0, minusDM = 0, tr = 0;
  for (let i = 1; i < Math.min(period + 1, ohlcData.length); i++) {
    const high = ohlcData[i].high, low = ohlcData[i].low;
    const prevHigh = ohlcData[i - 1].high, prevLow = ohlcData[i - 1].low, prevClose = ohlcData[i - 1].close;
    const upMove = high - prevHigh, downMove = prevLow - low;
    plusDM += upMove > downMove && upMove > 0 ? upMove : 0;
    minusDM += downMove > upMove && downMove > 0 ? downMove : 0;
    tr += calculateTrueRange(high, low, prevClose);
  }
  if (tr === 0) return 25;
  let plusDI = (plusDM / tr) * 100, minusDI = (minusDM / tr) * 100;
  let dx = Math.abs(plusDI - minusDI) / (plusDI + minusDI + 0.0001) * 100;
  let adx = dx;
  for (let i = period + 1; i < ohlcData.length; i++) {
    const high = ohlcData[i].high, low = ohlcData[i].low;
    const prevHigh = ohlcData[i - 1].high, prevLow = ohlcData[i - 1].low, prevClose = ohlcData[i - 1].close;
    const upMove = high - prevHigh, downMove = prevLow - low;
    const pDM = upMove > downMove && upMove > 0 ? upMove : 0;
    const mDM = downMove > upMove && downMove > 0 ? downMove : 0;
    const currTR = calculateTrueRange(high, low, prevClose);
    plusDM = plusDM - plusDM / period + pDM;
    minusDM = minusDM - minusDM / period + mDM;
    tr = tr - tr / period + currTR;
    plusDI = (plusDM / (tr + 0.0001)) * 100;
    minusDI = (minusDM / (tr + 0.0001)) * 100;
    dx = Math.abs(plusDI - minusDI) / (plusDI + minusDI + 0.0001) * 100;
    adx = (adx * (period - 1) + dx) / period;
  }
  return adx;
};

// ==================== MARKET REGIME DETECTION ====================
const MARKET_REGIMES = {
  TRENDING_UP: { name: 'Trending Up', icon: 'ðŸš€', color: 'emerald', strategy: 'momentum' },
  TRENDING_DOWN: { name: 'Trending Down', icon: 'ðŸ“‰', color: 'red', strategy: 'meanReversion' },
  RANGING: { name: 'Ranging', icon: 'â†”ï¸', color: 'amber', strategy: 'grid' },
  HIGH_VOLATILITY: { name: 'High Volatility', icon: 'âš¡', color: 'purple', strategy: 'scalp' }
};

const detectMarketRegime = (ohlcData, priceHistory) => {
  if (!ohlcData || ohlcData.length < 50) {
    return { regime: 'RANGING', confidence: 0.5, adx: 25, atr: 0, trend: 'neutral' };
  }
  const adx = calculateADX(ohlcData, 14);
  const atr = calculateATR(ohlcData, 14);
  const closes = ohlcData.map(c => c.close);
  const currentPrice = closes[closes.length - 1];
  const ema20 = calculateEMA(closes, 20);
  const ema50 = calculateEMA(closes, 50);
  const rsi = calculateRSI(closes);

  // Calculate average ATR for volatility comparison
  const atrHistory = [];
  for (let i = 20; i < ohlcData.length; i++) {
    atrHistory.push(calculateATR(ohlcData.slice(0, i + 1), 14));
  }
  const avgATR = atrHistory.length > 0 ? atrHistory.reduce((a, b) => a + b, 0) / atrHistory.length : atr;
  const volatilityRatio = atr / (avgATR + 0.0001);

  // Determine trend direction
  const trendUp = currentPrice > ema20 && ema20 > ema50;
  const trendDown = currentPrice < ema20 && ema20 < ema50;

  let regime = 'RANGING';
  let confidence = 0.5;

  if (volatilityRatio > 1.8) {
    regime = 'HIGH_VOLATILITY';
    confidence = Math.min(0.9, 0.5 + volatilityRatio * 0.2);
  } else if (adx > 25) {
    if (trendUp && rsi > 40) {
      regime = 'TRENDING_UP';
      confidence = Math.min(0.95, 0.5 + (adx - 25) / 50);
    } else if (trendDown && rsi < 60) {
      regime = 'TRENDING_DOWN';
      confidence = Math.min(0.95, 0.5 + (adx - 25) / 50);
    }
  } else {
    regime = 'RANGING';
    confidence = Math.min(0.85, 0.5 + (25 - adx) / 50);
  }

  return { regime, confidence, adx, atr, volatilityRatio, trend: trendUp ? 'up' : trendDown ? 'down' : 'neutral' };
};

// ==================== CANDLESTICK PATTERN RECOGNITION ====================
const detectCandlestickPatterns = (ohlcData) => {
  if (!ohlcData || ohlcData.length < 5) return [];
  const patterns = [];
  const len = ohlcData.length;

  // Helper functions
  const bodySize = (c) => Math.abs(c.close - c.open);
  const upperWick = (c) => c.high - Math.max(c.open, c.close);
  const lowerWick = (c) => Math.min(c.open, c.close) - c.low;
  const range = (c) => c.high - c.low;
  const isBullish = (c) => c.close > c.open;
  const isBearish = (c) => c.close < c.open;

  // Check last few candles
  const c0 = ohlcData[len - 1]; // Current
  const c1 = ohlcData[len - 2]; // Previous
  const c2 = ohlcData[len - 3]; // 2 ago

  // DOJI - Open and close nearly equal
  if (bodySize(c0) < range(c0) * 0.1 && range(c0) > 0) {
    patterns.push({ name: 'Doji', type: 'neutral', confidence: 0.7, description: 'Indecision - potential reversal' });
  }

  // HAMMER - Small body at top, long lower wick
  if (lowerWick(c0) > bodySize(c0) * 2 && upperWick(c0) < bodySize(c0) * 0.5 && bodySize(c0) > 0) {
    patterns.push({ name: 'Hammer', type: 'bullish', confidence: 0.75, description: 'Bullish reversal signal' });
  }

  // INVERTED HAMMER
  if (upperWick(c0) > bodySize(c0) * 2 && lowerWick(c0) < bodySize(c0) * 0.5 && bodySize(c0) > 0) {
    patterns.push({ name: 'Inverted Hammer', type: 'bullish', confidence: 0.65, description: 'Potential bullish reversal' });
  }

  // BULLISH ENGULFING
  if (isBearish(c1) && isBullish(c0) && c0.open < c1.close && c0.close > c1.open && bodySize(c0) > bodySize(c1)) {
    patterns.push({ name: 'Bullish Engulfing', type: 'bullish', confidence: 0.8, description: 'Strong bullish reversal' });
  }

  // BEARISH ENGULFING
  if (isBullish(c1) && isBearish(c0) && c0.open > c1.close && c0.close < c1.open && bodySize(c0) > bodySize(c1)) {
    patterns.push({ name: 'Bearish Engulfing', type: 'bearish', confidence: 0.8, description: 'Strong bearish reversal' });
  }

  // MORNING STAR (3 candle bullish reversal)
  if (len >= 3 && isBearish(c2) && bodySize(c1) < bodySize(c2) * 0.3 && isBullish(c0) && c0.close > (c2.open + c2.close) / 2) {
    patterns.push({ name: 'Morning Star', type: 'bullish', confidence: 0.85, description: 'Strong bullish reversal pattern' });
  }

  // EVENING STAR (3 candle bearish reversal)
  if (len >= 3 && isBullish(c2) && bodySize(c1) < bodySize(c2) * 0.3 && isBearish(c0) && c0.close < (c2.open + c2.close) / 2) {
    patterns.push({ name: 'Evening Star', type: 'bearish', confidence: 0.85, description: 'Strong bearish reversal pattern' });
  }

  // THREE WHITE SOLDIERS
  if (len >= 3 && isBullish(c2) && isBullish(c1) && isBullish(c0) && c1.close > c2.close && c0.close > c1.close &&
      bodySize(c0) > range(c0) * 0.6 && bodySize(c1) > range(c1) * 0.6 && bodySize(c2) > range(c2) * 0.6) {
    patterns.push({ name: 'Three White Soldiers', type: 'bullish', confidence: 0.9, description: 'Very strong bullish continuation' });
  }

  // THREE BLACK CROWS
  if (len >= 3 && isBearish(c2) && isBearish(c1) && isBearish(c0) && c1.close < c2.close && c0.close < c1.close &&
      bodySize(c0) > range(c0) * 0.6 && bodySize(c1) > range(c1) * 0.6 && bodySize(c2) > range(c2) * 0.6) {
    patterns.push({ name: 'Three Black Crows', type: 'bearish', confidence: 0.9, description: 'Very strong bearish continuation' });
  }

  return patterns;
};

// ==================== SUPPORT/RESISTANCE DETECTION ====================
const detectSupportResistance = (ohlcData, numLevels = 3) => {
  if (!ohlcData || ohlcData.length < 20) return { support: [], resistance: [] };

  const highs = ohlcData.map(c => c.high);
  const lows = ohlcData.map(c => c.low);
  const swingHighs = [], swingLows = [];

  // Find swing highs and lows (local maxima/minima)
  for (let i = 2; i < ohlcData.length - 2; i++) {
    if (highs[i] > highs[i-1] && highs[i] > highs[i-2] && highs[i] > highs[i+1] && highs[i] > highs[i+2]) {
      swingHighs.push({ price: highs[i], index: i });
    }
    if (lows[i] < lows[i-1] && lows[i] < lows[i-2] && lows[i] < lows[i+1] && lows[i] < lows[i+2]) {
      swingLows.push({ price: lows[i], index: i });
    }
  }

  // Cluster nearby levels
  const clusterLevels = (levels, tolerance = 0.01) => {
    if (levels.length === 0) return [];
    const sorted = [...levels].sort((a, b) => a.price - b.price);
    const clusters = [];
    let cluster = [sorted[0]];

    for (let i = 1; i < sorted.length; i++) {
      if ((sorted[i].price - cluster[0].price) / cluster[0].price < tolerance) {
        cluster.push(sorted[i]);
      } else {
        clusters.push({ price: cluster.reduce((s, l) => s + l.price, 0) / cluster.length, strength: cluster.length });
        cluster = [sorted[i]];
      }
    }
    clusters.push({ price: cluster.reduce((s, l) => s + l.price, 0) / cluster.length, strength: cluster.length });
    return clusters.sort((a, b) => b.strength - a.strength).slice(0, numLevels);
  };

  return {
    support: clusterLevels(swingLows),
    resistance: clusterLevels(swingHighs)
  };
};

// ==================== SENTIMENT ANALYSIS ====================
const calculateSentiment = (ohlcData, priceHistory) => {
  if (!ohlcData || ohlcData.length < 20) return { score: 0, label: 'Neutral', factors: [] };

  const closes = ohlcData.map(c => c.close);
  const volumes = ohlcData.map(c => c.volume || 1);
  const factors = [];
  let score = 0;

  // Volume sentiment: buying vs selling pressure
  let buyVolume = 0, sellVolume = 0;
  for (let i = 1; i < ohlcData.length; i++) {
    if (ohlcData[i].close > ohlcData[i].open) buyVolume += volumes[i];
    else sellVolume += volumes[i];
  }
  const volumeRatio = buyVolume / (sellVolume + 1);
  const volumeScore = Math.max(-30, Math.min(30, (volumeRatio - 1) * 30));
  score += volumeScore;
  factors.push({ name: 'Volume Pressure', value: volumeScore.toFixed(0), positive: volumeScore > 0 });

  // Momentum sentiment: RSI and MACD
  const rsi = calculateRSI(closes);
  const rsiScore = (rsi - 50) * 0.6; // -30 to +30
  score += rsiScore;
  factors.push({ name: 'RSI Momentum', value: rsiScore.toFixed(0), positive: rsiScore > 0 });

  // Trend sentiment: Price vs moving averages
  const sma20 = calculateSMA(closes, 20);
  const currentPrice = closes[closes.length - 1];
  const trendScore = ((currentPrice - sma20) / sma20) * 100;
  const cappedTrendScore = Math.max(-30, Math.min(30, trendScore * 3));
  score += cappedTrendScore;
  factors.push({ name: 'Trend Strength', value: cappedTrendScore.toFixed(0), positive: cappedTrendScore > 0 });

  // Cap total score
  score = Math.max(-100, Math.min(100, score));

  let label = 'Neutral';
  if (score > 40) label = 'Very Bullish';
  else if (score > 15) label = 'Bullish';
  else if (score < -40) label = 'Very Bearish';
  else if (score < -15) label = 'Bearish';

  return { score, label, factors };
};

// ==================== REINFORCEMENT LEARNING ====================
class ReplayBuffer {
  constructor(maxSize = 5000) {
    this.maxSize = maxSize;
    this.buffer = [];
    this.position = 0;
  }

  add(state, action, reward, nextState, done) {
    const experience = { state, action, reward, nextState, done };
    if (this.buffer.length < this.maxSize) {
      this.buffer.push(experience);
    } else {
      this.buffer[this.position] = experience;
    }
    this.position = (this.position + 1) % this.maxSize;
  }

  sample(batchSize = 32) {
    const batch = [];
    for (let i = 0; i < Math.min(batchSize, this.buffer.length); i++) {
      batch.push(this.buffer[Math.floor(Math.random() * this.buffer.length)]);
    }
    return batch;
  }

  size() { return this.buffer.length; }

  toJSON() { return { buffer: this.buffer.slice(-1000), position: this.position }; }

  fromJSON(data) {
    if (data?.buffer) {
      this.buffer = data.buffer;
      this.position = data.position || 0;
    }
  }
}

// Simple Q-Table based RL (works without TensorFlow)
class SimpleQLearning {
  constructor() {
    this.qTable = {}; // state -> [Q(buy), Q(hold), Q(sell)]
    this.learningRate = 0.1;
    this.discountFactor = 0.95;
    this.epsilon = 0.3; // Exploration rate
    this.minEpsilon = 0.05;
    this.epsilonDecay = 0.995;
    this.totalReward = 0;
    this.trainingSteps = 0;
  }

  getStateKey(state) {
    // Discretize state into buckets
    const rsiLevel = state.rsi < 30 ? 'oversold' : state.rsi > 70 ? 'overbought' : 'neutral';
    const trendLevel = state.trend > 0.02 ? 'up' : state.trend < -0.02 ? 'down' : 'flat';
    const regimeLevel = state.regime || 'unknown';
    const posLevel = state.hasPosition ? 'in' : 'out';
    return `${rsiLevel}_${trendLevel}_${regimeLevel}_${posLevel}`;
  }

  getQValues(state) {
    const key = this.getStateKey(state);
    if (!this.qTable[key]) {
      this.qTable[key] = [0, 0, 0]; // [buy, hold, sell]
    }
    return this.qTable[key];
  }

  selectAction(state) {
    // Epsilon-greedy
    if (Math.random() < this.epsilon) {
      return Math.floor(Math.random() * 3); // 0=buy, 1=hold, 2=sell
    }
    const qValues = this.getQValues(state);
    return qValues.indexOf(Math.max(...qValues));
  }

  update(state, action, reward, nextState, done) {
    const key = this.getStateKey(state);
    const qValues = this.getQValues(state);
    const nextQValues = this.getQValues(nextState);

    const maxNextQ = done ? 0 : Math.max(...nextQValues);
    const target = reward + this.discountFactor * maxNextQ;
    qValues[action] += this.learningRate * (target - qValues[action]);

    this.qTable[key] = qValues;
    this.totalReward += reward;
    this.trainingSteps++;

    // Decay epsilon
    this.epsilon = Math.max(this.minEpsilon, this.epsilon * this.epsilonDecay);
  }

  toJSON() {
    return { qTable: this.qTable, epsilon: this.epsilon, totalReward: this.totalReward, trainingSteps: this.trainingSteps };
  }

  fromJSON(data) {
    if (data) {
      this.qTable = data.qTable || {};
      this.epsilon = data.epsilon || 0.3;
      this.totalReward = data.totalReward || 0;
      this.trainingSteps = data.trainingSteps || 0;
    }
  }
}

// ==================== GENETIC ALGORITHM OPTIMIZER ====================
class StrategyEvolver {
  constructor() {
    this.populationSize = 15;
    this.mutationRate = 0.15;
    this.crossoverRate = 0.7;
    this.population = [];
    this.generation = 0;
    this.bestEver = null;
  }

  createIndividual() {
    return {
      stopLoss: 1 + Math.random() * 6,
      takeProfit: 2 + Math.random() * 12,
      tradeSize: 10 + Math.random() * 50,
      rsiOversold: 20 + Math.random() * 20,
      rsiOverbought: 60 + Math.random() * 30,
      fitness: 0
    };
  }

  initialize() {
    this.population = [];
    for (let i = 0; i < this.populationSize; i++) {
      this.population.push(this.createIndividual());
    }
  }

  mutate(individual) {
    const mutated = { ...individual };
    if (Math.random() < this.mutationRate) mutated.stopLoss = Math.max(0.5, mutated.stopLoss + (Math.random() - 0.5) * 2);
    if (Math.random() < this.mutationRate) mutated.takeProfit = Math.max(1, mutated.takeProfit + (Math.random() - 0.5) * 4);
    if (Math.random() < this.mutationRate) mutated.tradeSize = Math.max(5, Math.min(80, mutated.tradeSize + (Math.random() - 0.5) * 20));
    if (Math.random() < this.mutationRate) mutated.rsiOversold = Math.max(10, Math.min(40, mutated.rsiOversold + (Math.random() - 0.5) * 10));
    if (Math.random() < this.mutationRate) mutated.rsiOverbought = Math.max(60, Math.min(95, mutated.rsiOverbought + (Math.random() - 0.5) * 10));
    return mutated;
  }

  crossover(parent1, parent2) {
    if (Math.random() > this.crossoverRate) return { ...parent1 };
    return {
      stopLoss: Math.random() < 0.5 ? parent1.stopLoss : parent2.stopLoss,
      takeProfit: Math.random() < 0.5 ? parent1.takeProfit : parent2.takeProfit,
      tradeSize: Math.random() < 0.5 ? parent1.tradeSize : parent2.tradeSize,
      rsiOversold: Math.random() < 0.5 ? parent1.rsiOversold : parent2.rsiOversold,
      rsiOverbought: Math.random() < 0.5 ? parent1.rsiOverbought : parent2.rsiOverbought,
      fitness: 0
    };
  }

  evolve(fitnessResults) {
    // Update fitness
    fitnessResults.forEach((fitness, i) => {
      if (this.population[i]) this.population[i].fitness = fitness;
    });

    // Sort by fitness
    this.population.sort((a, b) => b.fitness - a.fitness);

    // Track best ever
    if (!this.bestEver || this.population[0].fitness > this.bestEver.fitness) {
      this.bestEver = { ...this.population[0] };
    }

    // Selection: keep top 40%
    const survivors = this.population.slice(0, Math.ceil(this.populationSize * 0.4));

    // Create new population
    const newPopulation = [...survivors];
    while (newPopulation.length < this.populationSize) {
      const parent1 = survivors[Math.floor(Math.random() * survivors.length)];
      const parent2 = survivors[Math.floor(Math.random() * survivors.length)];
      const child = this.mutate(this.crossover(parent1, parent2));
      newPopulation.push(child);
    }

    this.population = newPopulation;
    this.generation++;

    return this.population[0];
  }

  getBest() { return this.population.sort((a, b) => b.fitness - a.fitness)[0]; }

  toJSON() { return { population: this.population, generation: this.generation, bestEver: this.bestEver }; }

  fromJSON(data) {
    if (data) {
      this.population = data.population || [];
      this.generation = data.generation || 0;
      this.bestEver = data.bestEver || null;
      if (this.population.length === 0) this.initialize();
    }
  }
}

// ==================== PERFORMANCE TRACKER ====================
class PerformanceTracker {
  constructor() {
    this.trades = [];
    this.patternStats = {};
    this.regimeStats = {};
    this.strategyStats = {};
    this.equityHistory = [];
  }

  recordTrade(trade) {
    this.trades.push({ ...trade, timestamp: Date.now() });
    if (this.trades.length > 500) this.trades.shift();

    // Update pattern stats
    if (trade.pattern) {
      if (!this.patternStats[trade.pattern]) {
        this.patternStats[trade.pattern] = { wins: 0, losses: 0, totalPnL: 0 };
      }
      if (trade.pnl > 0) this.patternStats[trade.pattern].wins++;
      else this.patternStats[trade.pattern].losses++;
      this.patternStats[trade.pattern].totalPnL += trade.pnl || 0;
    }

    // Update regime stats
    if (trade.regime) {
      if (!this.regimeStats[trade.regime]) {
        this.regimeStats[trade.regime] = { wins: 0, losses: 0, totalPnL: 0 };
      }
      if (trade.pnl > 0) this.regimeStats[trade.regime].wins++;
      else this.regimeStats[trade.regime].losses++;
      this.regimeStats[trade.regime].totalPnL += trade.pnl || 0;
    }

    // Update strategy stats
    if (trade.strategy) {
      if (!this.strategyStats[trade.strategy]) {
        this.strategyStats[trade.strategy] = { wins: 0, losses: 0, totalPnL: 0 };
      }
      if (trade.pnl > 0) this.strategyStats[trade.strategy].wins++;
      else this.strategyStats[trade.strategy].losses++;
      this.strategyStats[trade.strategy].totalPnL += trade.pnl || 0;
    }
  }

  recordEquity(equity) {
    this.equityHistory.push({ time: Date.now(), equity });
    if (this.equityHistory.length > 500) this.equityHistory.shift();
  }

  getWinRate() {
    const completed = this.trades.filter(t => t.pnl !== undefined);
    if (completed.length === 0) return 0;
    return completed.filter(t => t.pnl > 0).length / completed.length * 100;
  }

  getSharpeRatio() {
    if (this.equityHistory.length < 10) return 0;
    const returns = [];
    for (let i = 1; i < this.equityHistory.length; i++) {
      returns.push((this.equityHistory[i].equity - this.equityHistory[i-1].equity) / this.equityHistory[i-1].equity);
    }
    const avgReturn = returns.reduce((a, b) => a + b, 0) / returns.length;
    const stdDev = Math.sqrt(returns.reduce((sum, r) => sum + Math.pow(r - avgReturn, 2), 0) / returns.length);
    return stdDev > 0 ? (avgReturn / stdDev) * Math.sqrt(252) : 0; // Annualized
  }

  getMaxDrawdown() {
    if (this.equityHistory.length < 2) return 0;
    let peak = this.equityHistory[0].equity;
    let maxDD = 0;
    for (const point of this.equityHistory) {
      if (point.equity > peak) peak = point.equity;
      const dd = (peak - point.equity) / peak * 100;
      if (dd > maxDD) maxDD = dd;
    }
    return maxDD;
  }

  getBestPattern() {
    let best = null, bestWinRate = 0;
    for (const [pattern, stats] of Object.entries(this.patternStats)) {
      const total = stats.wins + stats.losses;
      if (total >= 3) {
        const winRate = stats.wins / total;
        if (winRate > bestWinRate) { bestWinRate = winRate; best = pattern; }
      }
    }
    return best ? { pattern: best, winRate: bestWinRate * 100 } : null;
  }

  toJSON() {
    return { trades: this.trades.slice(-200), patternStats: this.patternStats, regimeStats: this.regimeStats,
             strategyStats: this.strategyStats, equityHistory: this.equityHistory.slice(-200) };
  }

  fromJSON(data) {
    if (data) {
      this.trades = data.trades || [];
      this.patternStats = data.patternStats || {};
      this.regimeStats = data.regimeStats || {};
      this.strategyStats = data.strategyStats || {};
      this.equityHistory = data.equityHistory || [];
    }
  }
}

// ==================== PROFIT MAXIMIZATION MODULES ====================

// Kelly Criterion - Optimal Position Sizing (Mathematically proven for max growth)
const calculateKellySize = (winRate, avgWin, avgLoss) => {
  // Kelly Formula: f* = (bp - q) / b
  // f* = fraction of capital to bet
  // b = odds (reward/risk ratio)
  // p = probability of winning
  // q = probability of losing (1 - p)
  const p = winRate;
  const q = 1 - winRate;
  const b = avgLoss > 0 ? avgWin / avgLoss : 2;
  const kelly = (b * p - q) / b;
  // Use fractional Kelly (half-Kelly for safety)
  return Math.max(0, Math.min(kelly * 0.5, 0.25)); // Max 25% of capital
};

// Paul Tudor Jones 200-Day MA Filter - Never be long below it
const calculate200DayMAFilter = (priceHistory) => {
  if (!priceHistory || priceHistory.length < 200) return { aboveMA: true, ma200: 0, distance: 0 };
  const ma200 = calculateSMA(priceHistory, 200);
  const currentPrice = priceHistory[priceHistory.length - 1];
  const distance = ((currentPrice - ma200) / ma200) * 100;
  return {
    aboveMA: currentPrice > ma200,
    ma200,
    distance,
    signal: currentPrice > ma200 ? 'ALLOW_LONGS' : 'EXIT_LONGS'
  };
};

// George Soros Asymmetric Risk/Reward Filter - Only trade when heavily skewed
const calculateAsymmetricRisk = (entryPrice, stopLoss, takeProfit, supportLevel, resistanceLevel) => {
  const risk = entryPrice - stopLoss;
  const reward = takeProfit - entryPrice;
  const ratio = risk > 0 ? reward / risk : 0;

  // Enhanced: Consider S/R levels
  const distToSupport = entryPrice - (supportLevel || entryPrice * 0.95);
  const distToResistance = (resistanceLevel || entryPrice * 1.10) - entryPrice;
  const srRatio = distToSupport > 0 ? distToResistance / distToSupport : 1;

  return {
    ratio,
    srRatio,
    quality: ratio >= 5 ? 'EXCELLENT' : ratio >= 3 ? 'GOOD' : ratio >= 2 ? 'ACCEPTABLE' : 'SKIP',
    suggestedSize: ratio >= 5 ? 'LARGE' : ratio >= 3 ? 'MEDIUM' : ratio >= 2 ? 'SMALL' : 'NONE'
  };
};

// Stanley Druckenmiller Concentration Rule - Bet big when conviction is high
const calculateDruckenmillerSize = (confidenceLevel, baseSize = 0.1) => {
  if (confidenceLevel > 0.85) return Math.min(0.30, baseSize * 3); // Up to 30%
  if (confidenceLevel > 0.70) return baseSize * 1.5;
  if (confidenceLevel > 0.55) return baseSize;
  return baseSize * 0.5; // Low conviction = small position
};

// Ed Seykota's Loss Cutting Rules - Maximum 2% loss per trade
const SEYKOTA_MAX_LOSS = 0.02; // 2% absolute maximum
const calculateSeykotaStopLoss = (entryPrice, accountBalance, positionSize) => {
  const maxLossDollars = accountBalance * SEYKOTA_MAX_LOSS;
  const maxPriceMove = maxLossDollars / positionSize;
  return entryPrice - maxPriceMove;
};

// Pyramiding System (Jesse Livermore Style) - Add to winning positions
class PyramidingManager {
  constructor() {
    this.pyramidLevels = [
      { threshold: 0.02, allocation: 0.25 }, // +2%: Add 25%
      { threshold: 0.04, allocation: 0.25 }, // +4%: Add 25%
      { threshold: 0.06, allocation: 0.25 }  // +6%: Add final 25%
    ];
    this.positions = {}; // Track pyramid state per pair
  }

  initPosition(pair, entryPrice, initialAllocation = 0.25) {
    this.positions[pair] = {
      entries: [{ price: entryPrice, allocation: initialAllocation }],
      totalAllocation: initialAllocation,
      breakeven: entryPrice,
      nextLevel: 0
    };
    return this.positions[pair];
  }

  shouldPyramid(pair, currentPrice) {
    const pos = this.positions[pair];
    if (!pos || pos.nextLevel >= this.pyramidLevels.length) return null;

    const avgEntry = this.getAverageEntry(pair);
    const pnlPct = (currentPrice - avgEntry) / avgEntry;
    const nextThreshold = this.pyramidLevels[pos.nextLevel].threshold;

    if (pnlPct >= nextThreshold) {
      return {
        shouldAdd: true,
        allocation: this.pyramidLevels[pos.nextLevel].allocation,
        reason: `Pyramid Level ${pos.nextLevel + 1} (+${(nextThreshold * 100).toFixed(0)}%)`
      };
    }
    return { shouldAdd: false };
  }

  addPyramidEntry(pair, price, allocation) {
    const pos = this.positions[pair];
    if (!pos) return;

    pos.entries.push({ price, allocation });
    pos.totalAllocation += allocation;
    pos.nextLevel++;

    // Recalculate breakeven
    let totalValue = 0, totalAlloc = 0;
    for (const entry of pos.entries) {
      totalValue += entry.price * entry.allocation;
      totalAlloc += entry.allocation;
    }
    pos.breakeven = totalValue / totalAlloc;

    return pos;
  }

  getAverageEntry(pair) {
    const pos = this.positions[pair];
    if (!pos || pos.entries.length === 0) return 0;

    let totalValue = 0, totalAlloc = 0;
    for (const entry of pos.entries) {
      totalValue += entry.price * entry.allocation;
      totalAlloc += entry.allocation;
    }
    return totalValue / totalAlloc;
  }

  closePosition(pair) {
    delete this.positions[pair];
  }

  toJSON() { return this.positions; }
  fromJSON(data) { if (data) this.positions = data; }
}

// Turtle Trading System - Proven Trend Following
const calculateTurtleSignals = (ohlcData) => {
  if (!ohlcData || ohlcData.length < 55) return { signal: 'NONE', breakout: null };

  const closes = ohlcData.map(c => c.close);
  const highs = ohlcData.map(c => c.high);
  const lows = ohlcData.map(c => c.low);
  const currentPrice = closes[closes.length - 1];

  // 20-day high/low (short-term)
  const high20 = Math.max(...highs.slice(-20));
  const low20 = Math.min(...lows.slice(-20));

  // 55-day high/low (long-term confirmation)
  const high55 = Math.max(...highs.slice(-55));
  const low55 = Math.min(...lows.slice(-55));

  // 10-day low for exits
  const low10 = Math.min(...lows.slice(-10));

  // ATR for position sizing and stops
  const atr = calculateATR(ohlcData, 20);

  let signal = 'NONE';
  let breakoutLevel = null;
  let stopLevel = null;

  // Entry: Break above 20-day high
  if (currentPrice > high20) {
    signal = currentPrice > high55 ? 'STRONG_BUY' : 'BUY';
    breakoutLevel = high20;
    stopLevel = currentPrice - (atr * 2); // 2Ã— ATR stop
  }
  // Exit: Break below 10-day low
  else if (currentPrice < low10) {
    signal = 'EXIT';
    breakoutLevel = low10;
  }

  // Position sizing: 1% risk per unit
  const unitSize = atr > 0 ? 0.01 / (atr / currentPrice) : 0.02;

  return {
    signal,
    breakoutLevel,
    stopLevel,
    high20,
    low20,
    high55,
    low10,
    atr,
    unitSize: Math.min(unitSize, 0.1) // Cap at 10%
  };
};

// VCP Pattern Detection (Mark Minervini's Volatility Contraction Pattern)
const detectVCPPattern = (ohlcData) => {
  if (!ohlcData || ohlcData.length < 50) return { isVCP: false };

  const closes = ohlcData.map(c => c.close);
  const highs = ohlcData.map(c => c.high);
  const lows = ohlcData.map(c => c.low);
  const volumes = ohlcData.map(c => c.volume || 1);

  // Find pullbacks (local peaks and troughs)
  const pullbacks = [];
  for (let i = 5; i < ohlcData.length - 5; i++) {
    const localHigh = Math.max(...highs.slice(i - 5, i + 5));
    const localLow = Math.min(...lows.slice(i - 5, i + 5));

    if (highs[i] === localHigh) {
      const nextLow = Math.min(...lows.slice(i, Math.min(i + 15, ohlcData.length)));
      const depth = (highs[i] - nextLow) / highs[i] * 100;
      const avgVol = volumes.slice(i, Math.min(i + 10, volumes.length)).reduce((a, b) => a + b, 0) / 10;
      pullbacks.push({ index: i, depth, volume: avgVol, high: highs[i] });
    }
  }

  if (pullbacks.length < 3) return { isVCP: false };

  // Check for contracting pullbacks
  let isContracting = true;
  for (let i = 1; i < pullbacks.length; i++) {
    if (pullbacks[i].depth >= pullbacks[i - 1].depth * 0.9) {
      isContracting = false;
      break;
    }
  }

  // Check for declining volume
  let volumeDecreasing = true;
  for (let i = 1; i < pullbacks.length; i++) {
    if (pullbacks[i].volume >= pullbacks[i - 1].volume) {
      volumeDecreasing = false;
      break;
    }
  }

  // Final tight consolidation
  const recentRange = (Math.max(...highs.slice(-10)) - Math.min(...lows.slice(-10))) / closes[closes.length - 1] * 100;
  const isTight = recentRange < 5;

  const isVCP = isContracting && volumeDecreasing && isTight;

  return {
    isVCP,
    pullbacks: pullbacks.slice(-3),
    contracting: isContracting,
    volumeDecreasing,
    tight: isTight,
    breakoutLevel: isVCP ? Math.max(...highs.slice(-10)) : null,
    confidence: (isContracting ? 0.33 : 0) + (volumeDecreasing ? 0.33 : 0) + (isTight ? 0.34 : 0)
  };
};

// Fear & Greed Calculator (Simulated from price action)
const calculateFearGreed = (ohlcData, priceHistory) => {
  if (!ohlcData || ohlcData.length < 30) return { score: 50, label: 'Neutral', signal: 'HOLD' };

  const closes = ohlcData.map(c => c.close);
  const volumes = ohlcData.map(c => c.volume || 1);
  const currentPrice = closes[closes.length - 1];
  const price30Ago = closes[Math.max(0, closes.length - 30)];

  let score = 50;

  // Price momentum (40% weight)
  const momentum = (currentPrice - price30Ago) / price30Ago;
  score += momentum * 100 * 0.4;

  // Volatility (30% weight) - high vol = fear
  const returns = [];
  for (let i = 1; i < Math.min(30, closes.length); i++) {
    returns.push((closes[i] - closes[i - 1]) / closes[i - 1]);
  }
  const volatility = Math.sqrt(returns.reduce((s, r) => s + r * r, 0) / returns.length) * Math.sqrt(252);
  const avgVolatility = 0.5; // Assume 50% annualized vol as average
  const volRatio = volatility / avgVolatility;
  score += volRatio > 1.5 ? -15 : volRatio < 0.5 ? 15 : 0;

  // Volume (30% weight)
  const recentVol = volumes.slice(-5).reduce((a, b) => a + b, 0) / 5;
  const avgVol = volumes.reduce((a, b) => a + b, 0) / volumes.length;
  const volRatioVol = recentVol / avgVol;
  score += volRatioVol > 2 ? 20 : volRatioVol < 0.5 ? -20 : 0;

  score = Math.max(0, Math.min(100, score));

  let label = 'Neutral';
  let signal = 'HOLD';
  if (score >= 80) { label = 'Extreme Greed'; signal = 'SELL_WARNING'; }
  else if (score >= 60) { label = 'Greed'; signal = 'CAUTION'; }
  else if (score <= 20) { label = 'Extreme Fear'; signal = 'STRONG_BUY'; }
  else if (score <= 40) { label = 'Fear'; signal = 'BUY'; }

  return { score, label, signal, momentum: momentum * 100, volatility: volatility * 100 };
};

// Compound Interest Optimizer - Reinvest profits optimally
class CompoundOptimizer {
  constructor() {
    this.baseCapital = 20;
    this.tradingCapital = 20;
    this.profitReserve = 0;
    this.compoundRate = 0.5; // Reinvest 50% of profits
    this.peakEquity = 20;
    this.drawdownReset = 0.15; // Reset if 15% drawdown
  }

  processWin(profit) {
    const toCompound = profit * this.compoundRate;
    const toReserve = profit * (1 - this.compoundRate);

    this.tradingCapital += toCompound;
    this.profitReserve += toReserve;

    const totalEquity = this.tradingCapital + this.profitReserve;
    if (totalEquity > this.peakEquity) this.peakEquity = totalEquity;

    return {
      compounded: toCompound,
      reserved: toReserve,
      newTradingCapital: this.tradingCapital,
      totalReserve: this.profitReserve
    };
  }

  processLoss(loss) {
    this.tradingCapital = Math.max(this.baseCapital * 0.5, this.tradingCapital - Math.abs(loss));

    // Check for drawdown reset
    const totalEquity = this.tradingCapital + this.profitReserve;
    const drawdown = (this.peakEquity - totalEquity) / this.peakEquity;

    if (drawdown >= this.drawdownReset) {
      // Reset trading capital from reserve
      const transfer = Math.min(this.profitReserve * 0.5, this.baseCapital - this.tradingCapital);
      this.tradingCapital += transfer;
      this.profitReserve -= transfer;
      this.peakEquity = totalEquity; // Reset peak
      return { reset: true, transferred: transfer };
    }

    return { reset: false, currentDrawdown: drawdown * 100 };
  }

  getStats() {
    const totalEquity = this.tradingCapital + this.profitReserve;
    return {
      tradingCapital: this.tradingCapital,
      profitReserve: this.profitReserve,
      totalEquity,
      totalReturn: ((totalEquity - this.baseCapital) / this.baseCapital) * 100,
      drawdown: ((this.peakEquity - totalEquity) / this.peakEquity) * 100
    };
  }

  toJSON() {
    return {
      baseCapital: this.baseCapital,
      tradingCapital: this.tradingCapital,
      profitReserve: this.profitReserve,
      peakEquity: this.peakEquity
    };
  }

  fromJSON(data) {
    if (data) {
      this.baseCapital = data.baseCapital || 20;
      this.tradingCapital = data.tradingCapital || 20;
      this.profitReserve = data.profitReserve || 0;
      this.peakEquity = data.peakEquity || 20;
    }
  }
}

// Multi-Timeframe Confluence Calculator
const calculateMultiTimeframeConfluence = (data1h, data4h, data1d) => {
  const getSignal = (data) => {
    if (!data || data.length < 20) return 0;
    const closes = data.map(c => c.close);
    const rsi = calculateRSI(closes);
    const sma20 = calculateSMA(closes, 20);
    const currentPrice = closes[closes.length - 1];

    let score = 0;
    if (rsi < 30) score += 1;
    else if (rsi > 70) score -= 1;
    if (currentPrice > sma20) score += 0.5;
    else score -= 0.5;

    return score;
  };

  const signal1h = getSignal(data1h);
  const signal4h = getSignal(data4h);
  const signal1d = getSignal(data1d);

  const totalScore = signal1h + signal4h * 1.5 + signal1d * 2; // Weight longer timeframes more
  const maxScore = 1.5 + 1.5 * 1.5 + 1.5 * 2; // 6.75 max

  const bullConfluence = signal1h > 0 && signal4h > 0 && signal1d > 0;
  const bearConfluence = signal1h < 0 && signal4h < 0 && signal1d < 0;

  return {
    bullConfluence,
    bearConfluence,
    strength: totalScore / maxScore,
    signals: { '1h': signal1h, '4h': signal4h, '1d': signal1d },
    recommendation: bullConfluence ? 'STRONG_BUY' : bearConfluence ? 'STRONG_SELL' :
                    totalScore > 1 ? 'BUY' : totalScore < -1 ? 'SELL' : 'HOLD'
  };
};

// Master Profit Rules Checker - The 10 Rules for Maximum Growth
const checkProfitRules = (context) => {
  const {
    currentLoss, position, ma200Filter, riskReward, confidence,
    fearGreed, sentiment, winRate, avgWin, avgLoss
  } = context;

  const violations = [];
  const recommendations = [];

  // Rule 1: Cut losses at 2% (Seykota)
  if (currentLoss && currentLoss >= 0.02) {
    violations.push('RULE 1: Cut loss NOW (2% max exceeded)');
  }

  // Rule 4: Never long below 200-day MA (PTJ)
  if (position && ma200Filter && !ma200Filter.aboveMA) {
    violations.push('RULE 4: Exit long - below 200-day MA');
  }

  // Rule 6: Only trade 3:1+ risk/reward (Soros)
  if (riskReward && riskReward.ratio < 2) {
    violations.push('RULE 6: Skip trade - R:R below 2:1');
  }

  // Rule 8: Contrarian at extremes
  if (fearGreed) {
    if (fearGreed.score <= 20) recommendations.push('RULE 8: Extreme fear - BUY opportunity');
    if (fearGreed.score >= 80) recommendations.push('RULE 8: Extreme greed - SELL/tighten stops');
  }

  // Calculate Kelly size recommendation
  const kellySize = calculateKellySize(winRate || 0.5, avgWin || 5, avgLoss || 3);
  recommendations.push(`RULE 5: Kelly suggests ${(kellySize * 100).toFixed(1)}% position size`);

  // Druckenmiller concentration
  if (confidence && confidence > 0.85) {
    recommendations.push('RULE 7: High conviction - consider larger position');
  }

  return {
    violations,
    recommendations,
    shouldTrade: violations.length === 0,
    kellySize
  };
};

// ==================== STORAGE ====================
const STORAGE_KEYS = {
  settings: 'kb-settings-v2',
  trades: 'kb-trades-v2',
  portfolio: 'kb-portfolio-v2',
  aiModel: 'kb-ai-model',
  rlAgent: 'kb-rl-agent',
  evolver: 'kb-evolver',
  perfTracker: 'kb-perf-tracker',
  pyramiding: 'kb-pyramiding',
  compound: 'kb-compound',
  proStrategies: 'kb-pro-strategies'
};

const saveToStorage = (key, data) => {
  try {
    localStorage.setItem(key, JSON.stringify(data));
    return true;
  } catch (e) {
    console.warn('Storage save failed:', e);
    return false;
  }
};

const loadFromStorage = (key, defaultValue) => {
  try {
    const data = localStorage.getItem(key);
    return data ? JSON.parse(data) : defaultValue;
  } catch (e) {
    return defaultValue;
  }
};

// ==================== MONTE CARLO SIMULATION ENGINE ====================
class MonteCarloSimulator {
  constructor(trades, numIterations = 1000) {
    this.trades = trades;
    this.numIterations = numIterations;
  }

  runSimulation(initialCapital = 10000) {
    const results = [];

    for (let iteration = 0; iteration < this.numIterations; iteration++) {
      const resampledTrades = this._bootstrapResample(this.trades);
      const equityCurve = this._calculateEquityCurve(resampledTrades, initialCapital);

      const returns = [];
      for (let i = 1; i < equityCurve.length; i++) {
        returns.push((equityCurve[i] - equityCurve[i-1]) / equityCurve[i-1]);
      }

      results.push({
        equityCurve,
        finalEquity: equityCurve[equityCurve.length - 1],
        totalReturn: (equityCurve[equityCurve.length - 1] - initialCapital) / initialCapital,
        maxDrawdown: this._calculateMaxDrawdown(equityCurve),
        maxDrawdownDuration: this._calculateDrawdownDuration(equityCurve),
        sharpeRatio: this._calculateSharpe(returns),
        sortinoRatio: this._calculateSortino(returns),
        winRate: resampledTrades.filter(t => t.pnl > 0).length / resampledTrades.length,
        profitFactor: this._calculateProfitFactor(resampledTrades)
      });
    }

    return this._analyzeResults(results, initialCapital);
  }

  _bootstrapResample(trades) {
    const resampled = [];
    for (let i = 0; i < trades.length; i++) {
      const randomIndex = Math.floor(Math.random() * trades.length);
      resampled.push({ ...trades[randomIndex] });
    }
    return resampled;
  }

  _calculateEquityCurve(trades, initialCapital) {
    let equity = initialCapital;
    const curve = [equity];

    for (const trade of trades) {
      const pnlPercent = trade.pnlPercent || trade.pnl || 0;
      equity *= (1 + pnlPercent / 100);
      curve.push(Math.max(0, equity));
    }

    return curve;
  }

  _calculateMaxDrawdown(equityCurve) {
    let maxRunup = equityCurve[0];
    let maxDrawdown = 0;

    for (const equity of equityCurve) {
      if (equity > maxRunup) maxRunup = equity;
      const drawdown = (maxRunup - equity) / maxRunup;
      if (drawdown > maxDrawdown) maxDrawdown = drawdown;
    }

    return maxDrawdown * 100;
  }

  _calculateDrawdownDuration(equityCurve) {
    let maxRunup = equityCurve[0];
    let peakIndex = 0;
    let maxDuration = 0;

    for (let i = 0; i < equityCurve.length; i++) {
      if (equityCurve[i] > maxRunup) {
        maxRunup = equityCurve[i];
        peakIndex = i;
      }
      const duration = i - peakIndex;
      if (duration > maxDuration) maxDuration = duration;
    }

    return maxDuration;
  }

  _calculateSharpe(returns) {
    if (returns.length < 2) return 0;
    const mean = returns.reduce((a, b) => a + b, 0) / returns.length;
    const variance = returns.reduce((sum, r) => sum + Math.pow(r - mean, 2), 0) / returns.length;
    const stdDev = Math.sqrt(variance);
    return stdDev > 0 ? (mean * Math.sqrt(252)) / stdDev : 0;
  }

  _calculateSortino(returns) {
    if (returns.length < 2) return 0;
    const mean = returns.reduce((a, b) => a + b, 0) / returns.length;
    const negativeReturns = returns.filter(r => r < 0);
    if (negativeReturns.length === 0) return mean > 0 ? 999 : 0;
    const downside = Math.sqrt(negativeReturns.reduce((sum, r) => sum + r * r, 0) / negativeReturns.length);
    return downside > 0 ? (mean * Math.sqrt(252)) / downside : 0;
  }

  _calculateProfitFactor(trades) {
    const grossProfit = trades.filter(t => (t.pnl || 0) > 0).reduce((sum, t) => sum + Math.abs(t.pnl || 0), 0);
    const grossLoss = trades.filter(t => (t.pnl || 0) <= 0).reduce((sum, t) => sum + Math.abs(t.pnl || 0), 0);
    return grossLoss > 0 ? grossProfit / grossLoss : (grossProfit > 0 ? 10 : 0);
  }

  _analyzeResults(results, initialCapital) {
    const sortedByReturn = [...results].sort((a, b) => a.totalReturn - b.totalReturn);
    const sortedByDrawdown = [...results].sort((a, b) => b.maxDrawdown - a.maxDrawdown);
    const sortedBySharpe = [...results].sort((a, b) => a.sharpeRatio - b.sharpeRatio);

    const n = results.length;
    const avgReturn = results.reduce((sum, r) => sum + r.totalReturn, 0) / n;
    const avgDrawdown = results.reduce((sum, r) => sum + r.maxDrawdown, 0) / n;
    const avgSharpe = results.reduce((sum, r) => sum + r.sharpeRatio, 0) / n;

    return {
      iterations: this.numIterations,
      summary: {
        avgReturn: avgReturn * 100,
        avgDrawdown: avgDrawdown,
        avgSharpe: avgSharpe,
        avgWinRate: results.reduce((sum, r) => sum + r.winRate, 0) / n * 100,
        avgProfitFactor: results.reduce((sum, r) => sum + r.profitFactor, 0) / n,
        profitablePct: results.filter(r => r.totalReturn > 0).length / n * 100
      },
      confidenceIntervals: {
        return95: {
          lower: sortedByReturn[Math.floor(n * 0.025)].totalReturn * 100,
          median: sortedByReturn[Math.floor(n * 0.5)].totalReturn * 100,
          upper: sortedByReturn[Math.floor(n * 0.975)].totalReturn * 100
        },
        drawdown95: {
          lower: sortedByDrawdown[Math.floor(n * 0.975)].maxDrawdown,
          median: sortedByDrawdown[Math.floor(n * 0.5)].maxDrawdown,
          upper: sortedByDrawdown[Math.floor(n * 0.025)].maxDrawdown
        },
        sharpe95: {
          lower: sortedBySharpe[Math.floor(n * 0.025)].sharpeRatio,
          median: sortedBySharpe[Math.floor(n * 0.5)].sharpeRatio,
          upper: sortedBySharpe[Math.floor(n * 0.975)].sharpeRatio
        }
      },
      worstCase: {
        maxDrawdown: sortedByDrawdown[0].maxDrawdown,
        worstReturn: sortedByReturn[0].totalReturn * 100,
        worstSharpe: sortedBySharpe[0].sharpeRatio
      },
      bestCase: {
        minDrawdown: sortedByDrawdown[n - 1].maxDrawdown,
        bestReturn: sortedByReturn[n - 1].totalReturn * 100,
        bestSharpe: sortedBySharpe[n - 1].sharpeRatio
      },
      distribution: {
        returns: results.map(r => r.totalReturn * 100),
        drawdowns: results.map(r => r.maxDrawdown),
        sharpes: results.map(r => r.sharpeRatio)
      }
    };
  }
}

// ==================== WALK-FORWARD OPTIMIZATION ====================
class WalkForwardOptimizer {
  constructor(ohlcData, trainingDays = 180, testingDays = 30) {
    this.data = ohlcData;
    this.trainingWindow = trainingDays;
    this.testingWindow = testingDays;
  }

  runWalkForward(strategy, parameterRanges) {
    const results = [];
    const totalBars = this.data.length;
    let trainingStart = 0;

    while (trainingStart + this.trainingWindow + this.testingWindow <= totalBars) {
      const trainingEnd = trainingStart + this.trainingWindow;
      const testingEnd = trainingEnd + this.testingWindow;

      const trainingData = this.data.slice(trainingStart, trainingEnd);
      const testingData = this.data.slice(trainingEnd, testingEnd);

      // Optimize on training data
      const optimalParams = this._optimizeParameters(strategy, trainingData, parameterRanges);

      // Test on out-of-sample data
      const testMetrics = this._backtest(strategy, testingData, optimalParams);

      results.push({
        period: { trainingStart, trainingEnd, testingStart: trainingEnd, testingEnd },
        optimalParams,
        inSampleMetrics: this._backtest(strategy, trainingData, optimalParams),
        outOfSampleMetrics: testMetrics,
        timestamp: this.data[trainingStart]?.timestamp || Date.now()
      });

      trainingStart += this.testingWindow;
    }

    return this._analyzeWalkForward(results);
  }

  _optimizeParameters(strategy, data, ranges) {
    let bestParams = null;
    let bestScore = -Infinity;

    for (const params of this._generateCombinations(ranges)) {
      const metrics = this._backtest(strategy, data, params);
      const score = metrics.sharpeRatio * 0.4 + metrics.profitFactor * 0.3 - metrics.maxDrawdown * 0.3;

      if (score > bestScore) {
        bestScore = score;
        bestParams = { ...params };
      }
    }

    return bestParams || Object.fromEntries(Object.entries(ranges).map(([k, v]) => [k, v[0]]));
  }

  *_generateCombinations(ranges) {
    const keys = Object.keys(ranges);
    const values = Object.values(ranges);

    function* generate(index = 0, current = {}) {
      if (index === keys.length) {
        yield { ...current };
        return;
      }
      const [min, max, step] = values[index];
      for (let val = min; val <= max; val += step) {
        current[keys[index]] = val;
        yield* generate(index + 1, current);
      }
    }
    yield* generate();
  }

  _backtest(strategy, data, params) {
    let equity = 10000;
    const trades = [];
    let position = null;

    for (let i = 50; i < data.length; i++) {
      const candle = data[i];
      const history = data.slice(0, i + 1);
      const signal = this._generateSignal(strategy, history, params);

      if (signal === 'BUY' && !position) {
        position = { entryPrice: candle.close, entryIndex: i, size: equity * 0.1 };
      } else if (signal === 'SELL' && position) {
        const pnl = ((candle.close - position.entryPrice) / position.entryPrice) * 100;
        equity *= (1 + pnl / 100);
        trades.push({ pnl, duration: i - position.entryIndex });
        position = null;
      }

      // Stop loss / take profit
      if (position) {
        const pnl = ((candle.close - position.entryPrice) / position.entryPrice) * 100;
        if (pnl <= -(params.stopLoss || 3) || pnl >= (params.takeProfit || 5)) {
          equity *= (1 + pnl / 100);
          trades.push({ pnl, duration: i - position.entryIndex });
          position = null;
        }
      }
    }

    return this._calculateMetrics(equity, trades);
  }

  _generateSignal(strategy, data, params) {
    const closes = data.map(c => c.close);
    const rsi = calculateRSI(closes, params.rsiPeriod || 14);
    const shortMA = calculateSMA(closes, params.shortMA || 10);
    const longMA = calculateSMA(closes, params.longMA || 30);

    if (strategy === 'rsi') {
      if (rsi < (params.oversold || 30)) return 'BUY';
      if (rsi > (params.overbought || 70)) return 'SELL';
    } else if (strategy === 'momentum' || strategy === 'macd') {
      if (shortMA > longMA) return 'BUY';
      if (shortMA < longMA) return 'SELL';
    }
    return 'HOLD';
  }

  _calculateMetrics(finalEquity, trades) {
    const returns = trades.map(t => t.pnl / 100);
    const winRate = trades.filter(t => t.pnl > 0).length / (trades.length || 1);
    const mean = returns.length > 0 ? returns.reduce((a, b) => a + b, 0) / returns.length : 0;
    const variance = returns.reduce((sum, r) => sum + Math.pow(r - mean, 2), 0) / (returns.length || 1);
    const stdDev = Math.sqrt(variance);

    const grossProfit = trades.filter(t => t.pnl > 0).reduce((sum, t) => sum + t.pnl, 0);
    const grossLoss = Math.abs(trades.filter(t => t.pnl <= 0).reduce((sum, t) => sum + t.pnl, 0));

    let maxDD = 0, peak = 10000, equity = 10000;
    for (const t of trades) {
      equity *= (1 + t.pnl / 100);
      if (equity > peak) peak = equity;
      const dd = (peak - equity) / peak;
      if (dd > maxDD) maxDD = dd;
    }

    return {
      totalReturn: (finalEquity - 10000) / 10000 * 100,
      sharpeRatio: stdDev > 0 ? (mean * Math.sqrt(252)) / stdDev : 0,
      winRate: winRate * 100,
      profitFactor: grossLoss > 0 ? grossProfit / grossLoss : (grossProfit > 0 ? 10 : 0),
      maxDrawdown: maxDD * 100,
      totalTrades: trades.length,
      expectancy: mean * 100
    };
  }

  _analyzeWalkForward(results) {
    const oos = results.map(r => r.outOfSampleMetrics);
    const is = results.map(r => r.inSampleMetrics);

    return {
      periods: results.length,
      outOfSample: {
        avgReturn: oos.reduce((sum, m) => sum + m.totalReturn, 0) / oos.length,
        avgSharpe: oos.reduce((sum, m) => sum + m.sharpeRatio, 0) / oos.length,
        avgWinRate: oos.reduce((sum, m) => sum + m.winRate, 0) / oos.length,
        avgProfitFactor: oos.reduce((sum, m) => sum + m.profitFactor, 0) / oos.length,
        avgDrawdown: oos.reduce((sum, m) => sum + m.maxDrawdown, 0) / oos.length,
        profitablePeriods: oos.filter(m => m.totalReturn > 0).length / oos.length * 100
      },
      inSample: {
        avgReturn: is.reduce((sum, m) => sum + m.totalReturn, 0) / is.length,
        avgSharpe: is.reduce((sum, m) => sum + m.sharpeRatio, 0) / is.length
      },
      degradation: {
        returnDegradation: (is.reduce((s, m) => s + m.totalReturn, 0) / is.length) -
                          (oos.reduce((s, m) => s + m.totalReturn, 0) / oos.length),
        sharpeDegradation: (is.reduce((s, m) => s + m.sharpeRatio, 0) / is.length) -
                          (oos.reduce((s, m) => s + m.sharpeRatio, 0) / oos.length)
      },
      robustness: oos.filter(m => m.totalReturn > 0).length / oos.length,
      periodResults: results
    };
  }
}

// ==================== STATISTICAL SIGNIFICANCE TESTING ====================
class StatisticalTester {
  constructor(trades, numBootstrap = 5000) {
    this.trades = trades;
    this.numBootstrap = numBootstrap;
    this.returns = trades.map(t => t.pnl || t.pnlPercent || 0);
  }

  runAllTests() {
    return {
      tTest: this.tTestZeroReturn(),
      bootstrapCI: this.bootstrapConfidenceInterval(),
      profitFactorTest: this.bootstrapProfitFactorTest(),
      randomizationTest: this.randomizationTest(),
      isStatisticallySignificant: this._overallSignificance()
    };
  }

  tTestZeroReturn() {
    if (this.returns.length < 5) return { tStatistic: 0, pValue: 1, isSignificant: false };

    const mean = this.returns.reduce((a, b) => a + b, 0) / this.returns.length;
    const variance = this.returns.reduce((sum, r) => sum + Math.pow(r - mean, 2), 0) / (this.returns.length - 1);
    const stdError = Math.sqrt(variance / this.returns.length);

    const tStat = stdError > 0 ? mean / stdError : 0;
    const pValue = 2 * this._normalCDF(-Math.abs(tStat));

    return {
      tStatistic: tStat,
      pValue: pValue,
      isSignificant: pValue < 0.05,
      interpretation: pValue < 0.05 ? 'Statistically significant (p < 0.05)' : 'Not significant - may be luck'
    };
  }

  bootstrapConfidenceInterval(confidence = 0.95) {
    const bootstrapMeans = [];

    for (let i = 0; i < this.numBootstrap; i++) {
      const sample = this._bootstrapResample(this.returns);
      bootstrapMeans.push(sample.reduce((a, b) => a + b, 0) / sample.length);
    }

    bootstrapMeans.sort((a, b) => a - b);
    const alpha = 1 - confidence;
    const lowerIdx = Math.floor(this.numBootstrap * alpha / 2);
    const upperIdx = Math.ceil(this.numBootstrap * (1 - alpha / 2));

    const lower = bootstrapMeans[lowerIdx];
    const upper = bootstrapMeans[upperIdx];

    return {
      lower: lower,
      upper: upper,
      mean: this.returns.reduce((a, b) => a + b, 0) / this.returns.length,
      excludesZero: lower > 0 || upper < 0,
      interpretation: lower > 0 ? '95% CI excludes zero - strategy is profitable' :
                     upper < 0 ? '95% CI negative - strategy is losing' :
                     'CI includes zero - inconclusive'
    };
  }

  bootstrapProfitFactorTest() {
    const factors = [];

    for (let i = 0; i < this.numBootstrap; i++) {
      const sample = this._bootstrapResample(this.trades);
      const grossProfit = sample.filter(t => (t.pnl || 0) > 0).reduce((sum, t) => sum + Math.abs(t.pnl || 0), 0);
      const grossLoss = sample.filter(t => (t.pnl || 0) <= 0).reduce((sum, t) => sum + Math.abs(t.pnl || 0), 0);
      factors.push(grossLoss > 0 ? grossProfit / grossLoss : 5);
    }

    factors.sort((a, b) => a - b);
    const pctBelowOne = factors.filter(f => f < 1).length / this.numBootstrap;

    return {
      medianProfitFactor: factors[Math.floor(this.numBootstrap / 2)],
      percentBelowOne: pctBelowOne * 100,
      isSignificant: pctBelowOne < 0.05,
      interpretation: pctBelowOne < 0.05 ? 'Profit factor significantly > 1.0' : 'Cannot confirm profitability'
    };
  }

  randomizationTest() {
    const actualMean = this.returns.reduce((a, b) => a + b, 0) / this.returns.length;
    let betterCount = 0;

    for (let i = 0; i < this.numBootstrap; i++) {
      const shuffled = this._shuffle([...this.returns]);
      const shuffledMean = shuffled.reduce((a, b) => a + b, 0) / shuffled.length;
      if (shuffledMean >= actualMean) betterCount++;
    }

    const pValue = betterCount / this.numBootstrap;

    return {
      actualMean: actualMean,
      pValue: pValue,
      isSignificant: pValue < 0.05,
      interpretation: pValue < 0.05 ? 'Returns not due to random chance' : 'Could be random - not significant'
    };
  }

  _overallSignificance() {
    const tTest = this.tTestZeroReturn();
    const bootstrap = this.bootstrapConfidenceInterval();
    const profitTest = this.bootstrapProfitFactorTest();

    const significantCount = [tTest.isSignificant, bootstrap.excludesZero && bootstrap.lower > 0, profitTest.isSignificant]
      .filter(Boolean).length;

    return {
      score: significantCount,
      verdict: significantCount >= 2 ? 'LIKELY PROFITABLE' : significantCount === 1 ? 'INCONCLUSIVE' : 'LIKELY LUCK',
      confidence: significantCount / 3 * 100
    };
  }

  _bootstrapResample(arr) {
    return Array.from({ length: arr.length }, () => arr[Math.floor(Math.random() * arr.length)]);
  }

  _shuffle(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  _normalCDF(x) {
    return 0.5 * (1 + this._erf(x / Math.sqrt(2)));
  }

  _erf(x) {
    const a1 = 0.254829592, a2 = -0.284496736, a3 = 1.421413741, a4 = -1.453152027, a5 = 1.061405429, p = 0.3275911;
    const sign = x < 0 ? -1 : 1;
    x = Math.abs(x);
    const t = 1 / (1 + p * x);
    return sign * (1 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x));
  }
}

// ==================== COMPREHENSIVE PERFORMANCE METRICS ====================
class PerformanceAnalyzer {
  constructor(trades, equityCurve, riskFreeRate = 0.02) {
    this.trades = trades;
    this.equityCurve = equityCurve;
    this.riskFreeRate = riskFreeRate;
    this.returns = this._calculateReturns();
  }

  _calculateReturns() {
    const returns = [];
    for (let i = 1; i < this.equityCurve.length; i++) {
      returns.push((this.equityCurve[i] - this.equityCurve[i-1]) / this.equityCurve[i-1]);
    }
    return returns;
  }

  generateFullReport() {
    const negReturns = this.returns.filter(r => r < 0);
    const posReturns = this.returns.filter(r => r > 0);

    return {
      returnMetrics: {
        totalReturn: ((this.equityCurve[this.equityCurve.length - 1] - this.equityCurve[0]) / this.equityCurve[0] * 100).toFixed(2) + '%',
        annualizedReturn: (this._annualizeReturn(this._geometricMean()) * 100).toFixed(2) + '%',
        dailyVolatility: (this._stdDev(this.returns) * 100).toFixed(3) + '%',
        annualizedVolatility: (this._stdDev(this.returns) * Math.sqrt(252) * 100).toFixed(2) + '%'
      },
      riskAdjusted: {
        sharpeRatio: this._sharpeRatio().toFixed(3),
        sortinoRatio: this._sortinoRatio().toFixed(3),
        calmarRatio: this._calmarRatio().toFixed(3),
        informationRatio: 'N/A (no benchmark)'
      },
      drawdown: {
        maxDrawdown: (this._maxDrawdown() * 100).toFixed(2) + '%',
        maxDrawdownDuration: this._maxDrawdownDuration() + ' periods',
        currentDrawdown: (this._currentDrawdown() * 100).toFixed(2) + '%',
        avgDrawdown: (this._avgDrawdown() * 100).toFixed(2) + '%'
      },
      tradeStats: {
        totalTrades: this.trades.length,
        winningTrades: this.trades.filter(t => (t.pnl || 0) > 0).length,
        losingTrades: this.trades.filter(t => (t.pnl || 0) <= 0).length,
        winRate: (this.trades.filter(t => (t.pnl || 0) > 0).length / (this.trades.length || 1) * 100).toFixed(1) + '%',
        avgWin: posReturns.length > 0 ? (posReturns.reduce((a, b) => a + b, 0) / posReturns.length * 100).toFixed(2) + '%' : '0%',
        avgLoss: negReturns.length > 0 ? (Math.abs(negReturns.reduce((a, b) => a + b, 0) / negReturns.length) * 100).toFixed(2) + '%' : '0%',
        profitFactor: this._profitFactor().toFixed(2),
        expectancy: (this._expectancy() * 100).toFixed(3) + '%'
      },
      tailRisk: {
        var95: (this._valueAtRisk(0.95) * 100).toFixed(2) + '%',
        var99: (this._valueAtRisk(0.99) * 100).toFixed(2) + '%',
        cvar95: (this._conditionalVaR(0.95) * 100).toFixed(2) + '%',
        maxLoss: (Math.min(...this.returns) * 100).toFixed(2) + '%',
        maxWin: (Math.max(...this.returns) * 100).toFixed(2) + '%'
      },
      consistency: {
        profitableMonths: 'N/A',
        avgMonthlyReturn: 'N/A',
        bestMonth: 'N/A',
        worstMonth: 'N/A'
      }
    };
  }

  _geometricMean() {
    if (this.returns.length === 0) return 0;
    const product = this.returns.reduce((p, r) => p * (1 + r), 1);
    return Math.pow(product, 1 / this.returns.length) - 1;
  }

  _stdDev(values) {
    if (values.length === 0) return 0;
    const mean = values.reduce((a, b) => a + b, 0) / values.length;
    return Math.sqrt(values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / values.length);
  }

  _annualizeReturn(dailyReturn) {
    return Math.pow(1 + dailyReturn, 252) - 1;
  }

  _sharpeRatio() {
    const annReturn = this._annualizeReturn(this._geometricMean());
    const annVol = this._stdDev(this.returns) * Math.sqrt(252);
    return annVol > 0 ? (annReturn - this.riskFreeRate) / annVol : 0;
  }

  _sortinoRatio() {
    const annReturn = this._annualizeReturn(this._geometricMean());
    const negReturns = this.returns.filter(r => r < 0);
    const downside = negReturns.length > 0 ? Math.sqrt(negReturns.reduce((sum, r) => sum + r * r, 0) / negReturns.length) * Math.sqrt(252) : 0.0001;
    return (annReturn - this.riskFreeRate) / downside;
  }

  _calmarRatio() {
    const annReturn = this._annualizeReturn(this._geometricMean());
    const maxDD = this._maxDrawdown();
    return maxDD > 0 ? annReturn / maxDD : 0;
  }

  _maxDrawdown() {
    let peak = this.equityCurve[0];
    let maxDD = 0;
    for (const eq of this.equityCurve) {
      if (eq > peak) peak = eq;
      const dd = (peak - eq) / peak;
      if (dd > maxDD) maxDD = dd;
    }
    return maxDD;
  }

  _maxDrawdownDuration() {
    let peak = this.equityCurve[0];
    let peakIdx = 0;
    let maxDur = 0;
    for (let i = 0; i < this.equityCurve.length; i++) {
      if (this.equityCurve[i] > peak) { peak = this.equityCurve[i]; peakIdx = i; }
      if (i - peakIdx > maxDur) maxDur = i - peakIdx;
    }
    return maxDur;
  }

  _currentDrawdown() {
    const peak = Math.max(...this.equityCurve);
    return (peak - this.equityCurve[this.equityCurve.length - 1]) / peak;
  }

  _avgDrawdown() {
    let peak = this.equityCurve[0];
    let totalDD = 0;
    let ddCount = 0;
    for (const eq of this.equityCurve) {
      if (eq > peak) peak = eq;
      const dd = (peak - eq) / peak;
      if (dd > 0) { totalDD += dd; ddCount++; }
    }
    return ddCount > 0 ? totalDD / ddCount : 0;
  }

  _profitFactor() {
    const grossProfit = this.trades.filter(t => (t.pnl || 0) > 0).reduce((sum, t) => sum + Math.abs(t.pnl || 0), 0);
    const grossLoss = this.trades.filter(t => (t.pnl || 0) <= 0).reduce((sum, t) => sum + Math.abs(t.pnl || 0), 0);
    return grossLoss > 0 ? grossProfit / grossLoss : (grossProfit > 0 ? 10 : 0);
  }

  _expectancy() {
    if (this.returns.length === 0) return 0;
    return this.returns.reduce((a, b) => a + b, 0) / this.returns.length;
  }

  _valueAtRisk(confidence) {
    const sorted = [...this.returns].sort((a, b) => a - b);
    const idx = Math.floor(sorted.length * (1 - confidence));
    return Math.abs(sorted[idx] || 0);
  }

  _conditionalVaR(confidence) {
    const sorted = [...this.returns].sort((a, b) => a - b);
    const idx = Math.floor(sorted.length * (1 - confidence));
    const worstReturns = sorted.slice(0, idx);
    return worstReturns.length > 0 ? Math.abs(worstReturns.reduce((a, b) => a + b, 0) / worstReturns.length) : 0;
  }
}

// ==================== REALISTIC MARKET SIMULATION ====================
class MarketSimulator {
  constructor(config = {}) {
    this.makerFee = config.makerFee || 0.001;  // 0.1%
    this.takerFee = config.takerFee || 0.0026; // 0.26% (Kraken)
    this.fundingRate = config.fundingRate || 0.0001;
  }

  calculateSlippage(orderSizeUSD, volume24hUSD, urgency = 'normal') {
    const sizeRatio = orderSizeUSD / (volume24hUSD || 1000000);

    let baseSlippage = 0;
    if (sizeRatio < 0.001) baseSlippage = 0.0001;      // 0.01%
    else if (sizeRatio < 0.01) baseSlippage = 0.0005;  // 0.05%
    else if (sizeRatio < 0.05) baseSlippage = 0.001;   // 0.1%
    else if (sizeRatio < 0.1) baseSlippage = 0.002;    // 0.2%
    else baseSlippage = 0.005;                          // 0.5%

    const urgencyMult = urgency === 'market' ? 1.5 : urgency === 'aggressive' ? 1.2 : 1.0;
    return baseSlippage * urgencyMult;
  }

  calculateMarketImpact(orderSizeUSD, volume24hUSD) {
    const sizeRatio = orderSizeUSD / (volume24hUSD || 1000000);
    return Math.sqrt(sizeRatio) * 0.001;
  }

  calculateTotalCost(orderPrice, orderSizeUSD, volume24hUSD, orderType = 'taker') {
    const fee = orderType === 'maker' ? this.makerFee : this.takerFee;
    const slippage = this.calculateSlippage(orderSizeUSD, volume24hUSD, orderType === 'taker' ? 'market' : 'limit');
    const impact = this.calculateMarketImpact(orderSizeUSD, volume24hUSD);

    const feeAmount = orderSizeUSD * fee;
    const slippageAmount = orderSizeUSD * slippage;
    const impactAmount = orderSizeUSD * impact;

    return {
      totalCost: feeAmount + slippageAmount + impactAmount,
      breakdown: { fee: feeAmount, slippage: slippageAmount, impact: impactAmount },
      effectivePrice: orderPrice * (1 + fee + slippage + impact),
      totalCostPercent: (fee + slippage + impact) * 100
    };
  }

  backtestWithRealisticCosts(trades, avgVolume = 10000000) {
    let equity = 10000;
    const adjustedTrades = [];

    for (const trade of trades) {
      const entryPrice = trade.entryPrice || trade.price || 100;
      const exitPrice = trade.exitPrice || entryPrice * (1 + (trade.pnl || 0) / 100);
      const size = trade.size || equity * 0.1;

      const entryCost = this.calculateTotalCost(entryPrice, size, avgVolume);
      const exitCost = this.calculateTotalCost(exitPrice, size, avgVolume);

      const grossPnL = (exitPrice - entryPrice) / entryPrice * size;
      const netPnL = grossPnL - entryCost.totalCost - exitCost.totalCost;

      equity += netPnL;
      adjustedTrades.push({
        ...trade,
        grossPnL,
        netPnL,
        totalCosts: entryCost.totalCost + exitCost.totalCost,
        costPercent: (entryCost.totalCostPercent + exitCost.totalCostPercent)
      });
    }

    const grossTotal = adjustedTrades.reduce((sum, t) => sum + t.grossPnL, 0);
    const netTotal = adjustedTrades.reduce((sum, t) => sum + t.netPnL, 0);
    const totalCosts = adjustedTrades.reduce((sum, t) => sum + t.totalCosts, 0);

    return {
      trades: adjustedTrades,
      summary: {
        grossPnL: grossTotal,
        netPnL: netTotal,
        totalCosts,
        costImpactPercent: Math.abs(grossTotal) > 0 ? (totalCosts / Math.abs(grossTotal) * 100) : 0,
        finalEquity: equity
      }
    };
  }
}

// ==================== AI-POWERED ANALYSIS ENGINE (OpenRouter) ====================
class AIAnalysisEngine {
  constructor(apiKey, model = 'anthropic/claude-3.5-sonnet') {
    this.apiKey = apiKey;
    this.model = model;
    this.baseUrl = 'https://openrouter.ai/api/v1/chat/completions';
  }

  async analyzeMarket(marketData) {
    const { pair, price, priceHistory, indicators, regime, patterns, sentiment } = marketData;

    const prompt = `You are an expert crypto trading analyst. Analyze this market data and provide actionable trading insights.

MARKET DATA FOR ${pair}:
- Current Price: $${price}
- 24h Change: ${((priceHistory[priceHistory.length - 1] - priceHistory[0]) / priceHistory[0] * 100).toFixed(2)}%
- RSI: ${indicators.rsi.toFixed(1)}
- MACD Histogram: ${indicators.macd.histogram.toFixed(4)}
- Market Regime: ${regime.regime} (${(regime.confidence * 100).toFixed(0)}% confidence)
- ADX (Trend Strength): ${regime.adx.toFixed(1)}
- Detected Patterns: ${patterns.map(p => p.name).join(', ') || 'None'}
- Sentiment Score: ${sentiment.score}/100 (${sentiment.label})

Provide a JSON response with:
{
  "signal": "BUY" | "SELL" | "HOLD",
  "confidence": 0-100,
  "entry_price": number or null,
  "stop_loss": number,
  "take_profit": number,
  "risk_reward": number,
  "reasoning": "brief explanation",
  "key_levels": { "support": number, "resistance": number },
  "timeframe": "short" | "medium" | "long",
  "warnings": ["any risks to consider"]
}`;

    try {
      const response = await fetch(this.baseUrl, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
          'Content-Type': 'application/json',
          'HTTP-Referer': window.location.href,
          'X-Title': 'Fitcher Trading'
        },
        body: JSON.stringify({
          model: this.model,
          messages: [{ role: 'user', content: prompt }],
          temperature: 0.3,
          max_tokens: 1000
        })
      });

      if (!response.ok) throw new Error(`API error: ${response.status}`);

      const data = await response.json();
      const content = data.choices[0]?.message?.content || '';

      // Parse JSON from response
      const jsonMatch = content.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        return { success: true, analysis: JSON.parse(jsonMatch[0]), raw: content };
      }
      return { success: true, analysis: null, raw: content };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  async generateStrategy(tradeHistory, performanceMetrics) {
    const prompt = `You are a quantitative trading strategist. Analyze this trading history and suggest improvements.

TRADE HISTORY (last 20 trades):
${JSON.stringify(tradeHistory.slice(-20), null, 2)}

PERFORMANCE METRICS:
- Win Rate: ${performanceMetrics.winRate}%
- Profit Factor: ${performanceMetrics.profitFactor}
- Sharpe Ratio: ${performanceMetrics.sharpeRatio}
- Max Drawdown: ${performanceMetrics.maxDrawdown}%
- Avg Win: ${performanceMetrics.avgWin}%
- Avg Loss: ${performanceMetrics.avgLoss}%

Provide JSON with strategy improvements:
{
  "analysis": "what's working and what's not",
  "improvements": [
    { "area": "entry", "suggestion": "...", "expected_impact": "..." },
    { "area": "exit", "suggestion": "...", "expected_impact": "..." },
    { "area": "risk", "suggestion": "...", "expected_impact": "..." }
  ],
  "recommended_settings": {
    "stop_loss": number,
    "take_profit": number,
    "position_size": number,
    "best_strategy": "momentum" | "rsi" | "macd" | "grid" | "dca"
  },
  "market_conditions": "when this strategy works best",
  "confidence": 0-100
}`;

    try {
      const response = await fetch(this.baseUrl, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
          'Content-Type': 'application/json',
          'HTTP-Referer': window.location.href,
          'X-Title': 'Fitcher Trading'
        },
        body: JSON.stringify({
          model: this.model,
          messages: [{ role: 'user', content: prompt }],
          temperature: 0.4,
          max_tokens: 1500
        })
      });

      if (!response.ok) throw new Error(`API error: ${response.status}`);

      const data = await response.json();
      const content = data.choices[0]?.message?.content || '';

      const jsonMatch = content.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        return { success: true, strategy: JSON.parse(jsonMatch[0]), raw: content };
      }
      return { success: true, strategy: null, raw: content };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  async analyzeNews(pair, headlines) {
    const prompt = `Analyze these crypto news headlines for ${pair} trading impact:

${headlines.map((h, i) => `${i + 1}. ${h}`).join('\n')}

Return JSON:
{
  "overall_sentiment": -100 to 100,
  "impact_level": "low" | "medium" | "high",
  "trading_bias": "bullish" | "bearish" | "neutral",
  "key_events": ["event1", "event2"],
  "recommendation": "brief action recommendation"
}`;

    try {
      const response = await fetch(this.baseUrl, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
          'Content-Type': 'application/json',
          'HTTP-Referer': window.location.href
        },
        body: JSON.stringify({
          model: 'anthropic/claude-3-haiku', // Use faster model for news
          messages: [{ role: 'user', content: prompt }],
          temperature: 0.2,
          max_tokens: 500
        })
      });

      const data = await response.json();
      const content = data.choices[0]?.message?.content || '';
      const jsonMatch = content.match(/\{[\s\S]*\}/);
      return jsonMatch ? { success: true, analysis: JSON.parse(jsonMatch[0]) } : { success: false };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }
}

// ==================== NEWS & SENTIMENT FETCHERS ====================
const fetchCryptoNews = async (pair) => {
  // Use CryptoCompare News API (free tier)
  const symbol = pair.split('/')[0];
  try {
    const response = await fetch(`https://min-api.cryptocompare.com/data/v2/news/?categories=${symbol}&excludeCategories=Sponsored`);
    const data = await response.json();
    if (data.Data) {
      return data.Data.slice(0, 10).map(article => ({
        title: article.title,
        source: article.source,
        url: article.url,
        published: new Date(article.published_on * 1000).toLocaleString(),
        sentiment: article.sentiment || 'neutral'
      }));
    }
  } catch (e) {
    console.error('News fetch error:', e);
  }
  return [];
};

const fetchFearGreedIndex = async () => {
  try {
    const response = await fetch('https://api.alternative.me/fng/?limit=1');
    const data = await response.json();
    if (data.data && data.data[0]) {
      return {
        value: parseInt(data.data[0].value),
        classification: data.data[0].value_classification,
        timestamp: data.data[0].timestamp
      };
    }
  } catch (e) {
    console.error('Fear & Greed fetch error:', e);
  }
  return { value: 50, classification: 'Neutral' };
};

// ==================== PORTFOLIO OPTIMIZATION (Modern Portfolio Theory) ====================
class PortfolioOptimizer {
  constructor(returns, riskFreeRate = 0.02) {
    this.returns = returns; // { 'BTC/USD': [returns], 'ETH/USD': [returns], ... }
    this.riskFreeRate = riskFreeRate / 252; // Daily
  }

  calculateCorrelationMatrix() {
    const pairs = Object.keys(this.returns);
    const matrix = {};

    for (const pair1 of pairs) {
      matrix[pair1] = {};
      for (const pair2 of pairs) {
        matrix[pair1][pair2] = this._correlation(this.returns[pair1], this.returns[pair2]);
      }
    }
    return matrix;
  }

  _correlation(arr1, arr2) {
    const n = Math.min(arr1.length, arr2.length);
    if (n < 5) return 0;

    const mean1 = arr1.slice(-n).reduce((a, b) => a + b, 0) / n;
    const mean2 = arr2.slice(-n).reduce((a, b) => a + b, 0) / n;

    let num = 0, den1 = 0, den2 = 0;
    for (let i = 0; i < n; i++) {
      const d1 = arr1[arr1.length - n + i] - mean1;
      const d2 = arr2[arr2.length - n + i] - mean2;
      num += d1 * d2;
      den1 += d1 * d1;
      den2 += d2 * d2;
    }

    return (den1 > 0 && den2 > 0) ? num / Math.sqrt(den1 * den2) : 0;
  }

  calculateOptimalWeights(targetReturn = null) {
    const pairs = Object.keys(this.returns);
    const n = pairs.length;

    // Calculate expected returns and covariance matrix
    const expectedReturns = {};
    const volatilities = {};

    for (const pair of pairs) {
      const rets = this.returns[pair];
      expectedReturns[pair] = rets.reduce((a, b) => a + b, 0) / rets.length * 252; // Annualized
      const mean = rets.reduce((a, b) => a + b, 0) / rets.length;
      volatilities[pair] = Math.sqrt(rets.reduce((s, r) => s + Math.pow(r - mean, 2), 0) / rets.length) * Math.sqrt(252);
    }

    // Simple equal-risk contribution for now (more sophisticated MPT requires matrix algebra)
    const invVols = pairs.map(p => 1 / (volatilities[p] || 1));
    const sumInvVols = invVols.reduce((a, b) => a + b, 0);
    const weights = {};

    pairs.forEach((pair, i) => {
      weights[pair] = (invVols[i] / sumInvVols * 100).toFixed(1);
    });

    // Calculate portfolio metrics
    let portfolioReturn = 0;
    let portfolioVol = 0;

    for (const pair of pairs) {
      const w = parseFloat(weights[pair]) / 100;
      portfolioReturn += w * expectedReturns[pair];
      portfolioVol += Math.pow(w * volatilities[pair], 2); // Simplified (ignores correlations)
    }
    portfolioVol = Math.sqrt(portfolioVol);

    return {
      weights,
      expectedReturns,
      volatilities,
      portfolioReturn: (portfolioReturn * 100).toFixed(2) + '%',
      portfolioVolatility: (portfolioVol * 100).toFixed(2) + '%',
      sharpeRatio: ((portfolioReturn - this.riskFreeRate * 252) / portfolioVol).toFixed(2),
      correlationMatrix: this.calculateCorrelationMatrix()
    };
  }
}

// ==================== VOICE ALERTS (Text-to-Speech) ====================
const speakAlert = (message, priority = 'normal') => {
  if ('speechSynthesis' in window) {
    const utterance = new SpeechSynthesisUtterance(message);
    utterance.rate = priority === 'urgent' ? 1.2 : 1.0;
    utterance.pitch = priority === 'urgent' ? 1.1 : 1.0;
    utterance.volume = priority === 'urgent' ? 1.0 : 0.8;
    window.speechSynthesis.speak(utterance);
  }
};

// ==================== ADVANCED RISK MANAGEMENT FUNCTIONS ====================

// Value at Risk (VaR) Calculation - Historical Method
const calculateVaR = (returns, confidence = 0.95) => {
  if (!returns || returns.length < 20) return { var95: 0, var99: 0, expectedShortfall: 0 };

  const sorted = [...returns].sort((a, b) => a - b);
  const index95 = Math.floor(returns.length * (1 - 0.95));
  const index99 = Math.floor(returns.length * (1 - 0.99));

  const var95 = Math.abs(sorted[index95] || 0) * 100;
  const var99 = Math.abs(sorted[index99] || 0) * 100;

  // Expected Shortfall (CVaR) - average of worst losses
  const worstLosses = sorted.slice(0, index95);
  const expectedShortfall = worstLosses.length > 0
    ? Math.abs(worstLosses.reduce((a, b) => a + b, 0) / worstLosses.length) * 100
    : 0;

  return { var95, var99, expectedShortfall };
};

// Liquidity-Adjusted Position Sizing
const calculateLiquidityAdjustedSize = (pair, baseSize, volume24h, avgVolume) => {
  // Reduce position size for illiquid pairs
  const volumeRatio = volume24h / (avgVolume || volume24h || 1);
  const liquidityFactor = Math.min(1, Math.sqrt(volumeRatio));

  // High-cap coins get full size, low-cap gets reduced
  const highLiquidityPairs = ['BTC/USD', 'ETH/USD', 'SOL/USD', 'XRP/USD'];
  const isHighLiquidity = highLiquidityPairs.includes(pair);

  const adjustedSize = isHighLiquidity ? baseSize : baseSize * liquidityFactor * 0.8;
  return {
    adjustedSize: Math.max(0.01, adjustedSize),
    liquidityFactor,
    warning: liquidityFactor < 0.5 ? 'Low liquidity - reduced position size' : null
  };
};

// Realistic Slippage Calculation
const calculateSlippage = (orderSize, price, volume, volatility = 0.02) => {
  // Base slippage (0.05%)
  const baseSlippage = 0.0005;

  // Volume impact - larger orders relative to volume cause more slippage
  const volumeImpact = orderSize / (volume * price || 1);
  const volumeSlippage = Math.min(0.02, volumeImpact * 10); // Cap at 2%

  // Volatility impact - higher volatility means more slippage
  const volatilitySlippage = volatility * 0.5;

  const totalSlippage = baseSlippage + volumeSlippage + volatilitySlippage;

  return {
    slippagePercent: totalSlippage * 100,
    executionPrice: price * (1 + totalSlippage), // For buys
    impact: totalSlippage * orderSize * price
  };
};

// Correlation Matrix for Risk Management
const calculateCorrelationMatrix = (priceHistories, pairs) => {
  const returns = {};
  const correlations = {};

  // Calculate returns for each pair
  for (const pair of pairs) {
    const history = priceHistories[pair];
    if (history && history.length > 20) {
      returns[pair] = [];
      for (let i = 1; i < history.length; i++) {
        returns[pair].push((history[i] - history[i-1]) / history[i-1]);
      }
    }
  }

  // Calculate pairwise correlations
  for (const pair1 of pairs) {
    correlations[pair1] = {};
    for (const pair2 of pairs) {
      if (returns[pair1] && returns[pair2]) {
        const r1 = returns[pair1];
        const r2 = returns[pair2];
        const n = Math.min(r1.length, r2.length);

        if (n > 10) {
          const mean1 = r1.slice(-n).reduce((a, b) => a + b, 0) / n;
          const mean2 = r2.slice(-n).reduce((a, b) => a + b, 0) / n;

          let num = 0, den1 = 0, den2 = 0;
          for (let i = 0; i < n; i++) {
            const d1 = r1[r1.length - n + i] - mean1;
            const d2 = r2[r2.length - n + i] - mean2;
            num += d1 * d2;
            den1 += d1 * d1;
            den2 += d2 * d2;
          }

          correlations[pair1][pair2] = den1 > 0 && den2 > 0 ? num / Math.sqrt(den1 * den2) : 0;
        } else {
          correlations[pair1][pair2] = pair1 === pair2 ? 1 : 0;
        }
      }
    }
  }

  return correlations;
};

// Daily Reset Check
const checkDailyReset = (riskState, currentBalance) => {
  const today = new Date().toDateString();
  if (riskState.lastDayReset !== today) {
    return {
      ...riskState,
      dailyPnL: 0,
      dailyStartBalance: currentBalance,
      lastDayReset: today,
      tradingPaused: false,
      pauseReason: '',
      consecutiveLosses: 0
    };
  }
  return riskState;
};

// Check if trading should be paused
const shouldPauseTrading = (riskState, currentBalance, lastTradeResult) => {
  const reasons = [];

  // Daily loss limit check
  const dailyPnLPercent = (currentBalance - riskState.dailyStartBalance) / riskState.dailyStartBalance;
  if (dailyPnLPercent <= -riskState.dailyLossLimit) {
    reasons.push(`Daily loss limit hit (${(dailyPnLPercent * 100).toFixed(2)}%)`);
  }

  // Consecutive losses check
  let newConsecutiveLosses = riskState.consecutiveLosses;
  if (lastTradeResult === 'loss') {
    newConsecutiveLosses++;
    if (newConsecutiveLosses >= riskState.maxConsecutiveLosses) {
      reasons.push(`${newConsecutiveLosses} consecutive losses`);
    }
  } else if (lastTradeResult === 'win') {
    newConsecutiveLosses = 0;
  }

  // Cooldown check
  if (riskState.cooldownUntil && new Date() < new Date(riskState.cooldownUntil)) {
    reasons.push(`Cooldown active until ${new Date(riskState.cooldownUntil).toLocaleTimeString()}`);
  }

  return {
    shouldPause: reasons.length > 0,
    reasons,
    consecutiveLosses: newConsecutiveLosses,
    cooldownUntil: reasons.length > 0 && !riskState.cooldownUntil
      ? new Date(Date.now() + riskState.cooldownMinutes * 60000).toISOString()
      : riskState.cooldownUntil
  };
};

// Desktop Notification Helper
const sendNotification = (title, body, type = 'info') => {
  // Play sound
  const sounds = {
    success: [800, 100, 1000, 100],
    warning: [400, 200, 400, 200],
    error: [200, 300, 200, 300],
    info: [600, 150]
  };

  try {
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const pattern = sounds[type] || sounds.info;
    let time = ctx.currentTime;

    for (let i = 0; i < pattern.length; i += 2) {
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.connect(gain);
      gain.connect(ctx.destination);
      osc.frequency.value = pattern[i];
      gain.gain.value = 0.1;
      osc.start(time);
      osc.stop(time + pattern[i + 1] / 1000);
      time += pattern[i + 1] / 1000 + 0.05;
    }
  } catch (e) { /* Audio not available */ }

  // Desktop notification
  if ('Notification' in window && Notification.permission === 'granted') {
    new Notification(title, {
      body,
      icon: type === 'success' ? 'âœ…' : type === 'error' ? 'âŒ' : type === 'warning' ? 'âš ï¸' : 'â„¹ï¸',
      tag: 'trading-bot'
    });
  }
};

// Export Trades to CSV
const exportTradesToCSV = (trades, filename = 'trading-bot-trades.csv') => {
  const headers = ['Date', 'Time', 'Pair', 'Type', 'Entry Price', 'Exit Price', 'Amount', 'P&L', 'P&L %', 'Strategy', 'Reason'];

  const rows = trades.map(t => [
    new Date(t.timestamp || Date.now()).toLocaleDateString(),
    new Date(t.timestamp || Date.now()).toLocaleTimeString(),
    t.pair || '',
    t.type || '',
    t.entryPrice || t.price || '',
    t.exitPrice || '',
    t.amount || '',
    t.pnl ? t.pnl.toFixed(4) : '',
    t.pnlPercent ? t.pnlPercent.toFixed(2) + '%' : '',
    t.strategy || '',
    t.reason || ''
  ]);

  const csv = [headers.join(','), ...rows.map(r => r.join(','))].join('\n');
  const blob = new Blob([csv], { type: 'text/csv' });
  const url = URL.createObjectURL(blob);

  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
};

// ==================== MAIN COMPONENT ====================
function KrakenTradingBot() {
  // Core state
  const [mode, setMode] = useState('paper');
  const [selectedPair, setSelectedPair] = useState('BTC/USD');
  const [balance, setBalance] = useState(20);
  const [initialBalance] = useState(20);
  const [positions, setPositions] = useState({});
  const [trades, setTrades] = useState([]);
  const [isRunning, setIsRunning] = useState(false);
  const [loading, setLoading] = useState(true);

  // Market data
  const [prices, setPrices] = useState({});
  const [priceHistory, setPriceHistory] = useState({});
  const [orderBook, setOrderBook] = useState({ bids: [], asks: [] });

  // Settings
  const [settings, setSettings] = useState({
    strategy: 'momentum',
    stopLoss: 3,
    takeProfit: 5,
    tradeSize: 20,
    apiKey: '',
    apiSecret: '',
    openRouterKey: '', // OpenRouter API key for AI analysis
    aiModel: 'anthropic/claude-3.5-sonnet', // Default AI model
    soundEnabled: true,
    trailingStop: true,
    trailingPercent: 1.5,
    gridLevels: 5,
    gridSpacing: 1,
    dcaInterval: 60,
    chartType: 'line'
  });

  // AI Analysis State
  const [aiAnalysis, setAiAnalysis] = useState(null);
  const [isAiAnalyzing, setIsAiAnalyzing] = useState(false);
  const [aiHistory, setAiHistory] = useState([]);
  const [newsSentiment, setNewsSentiment] = useState({ score: 0, headlines: [], lastUpdate: null });
  const [socialSentiment, setSocialSentiment] = useState({ twitter: 0, reddit: 0, fear_greed: 50 });
  const [whaleActivity, setWhaleActivity] = useState({ large_txns: [], net_flow: 0 });

  // UI state
  const [activeTab, setActiveTab] = useState('chart');
  const [showSettings, setShowSettings] = useState(false);
  const [timeframe, setTimeframe] = useState('1h');
  const [logs, setLogs] = useState([]);

  // API state
  const [apiStatus, setApiStatus] = useState('disconnected');
  const [activeExchange, setActiveExchange] = useState('kraken'); // Multi-exchange support
  const wsRef = useRef(null);
  const binanceWsRef = useRef(null);
  const coinbaseWsRef = useRef(null);
  const priceHistoryRef = useRef({});

  // Backtest state - NEW: Custom time period
  const [backtestResults, setBacktestResults] = useState(null);
  const [backtestProgress, setBacktestProgress] = useState(0);
  const [isBacktesting, setIsBacktesting] = useState(false);
  const [backtestConfig, setBacktestConfig] = useState({
    hoursBack: 36,
    useCustomDate: false,
    customStartDate: '',
    customEndDate: ''
  });
  const [historicalData, setHistoricalData] = useState({});
  const [dataStatus, setDataStatus] = useState('');

  // Scanner/Optimizer state
  const [scanResults, setScanResults] = useState([]);
  const [optimizerResults, setOptimizerResults] = useState(null);
  const [isScanning, setIsScanning] = useState(false);
  const [isOptimizing, setIsOptimizing] = useState(false);

  // AI Intelligence State
  const [marketRegime, setMarketRegime] = useState({ regime: 'RANGING', confidence: 0.5, adx: 25, atr: 0 });
  const [detectedPatterns, setDetectedPatterns] = useState([]);
  const [supportResistance, setSupportResistance] = useState({ support: [], resistance: [] });
  const [sentiment, setSentiment] = useState({ score: 0, label: 'Neutral', factors: [] });
  const [aiEnabled, setAiEnabled] = useState(true);
  const [autoStrategy, setAutoStrategy] = useState(true);

  // RL and Evolution State
  const rlAgentRef = useRef(new SimpleQLearning());
  const evolverRef = useRef(new StrategyEvolver());
  const perfTrackerRef = useRef(new PerformanceTracker());
  const replayBufferRef = useRef(new ReplayBuffer());
  const [rlStats, setRlStats] = useState({ epsilon: 0.3, totalReward: 0, trainingSteps: 0 });
  const [evolverStats, setEvolverStats] = useState({ generation: 0, bestFitness: 0 });
  const [isEvolving, setIsEvolving] = useState(false);
  const lastStateRef = useRef(null);
  const lastActionRef = useRef(null);

  // Pro Strategies State (Legendary Trader Rules)
  const pyramidManagerRef = useRef(new PyramidingManager());
  const compoundOptimizerRef = useRef(new CompoundOptimizer());
  const [proStrategiesEnabled, setProStrategiesEnabled] = useState(true);
  const [proStrategySettings, setProStrategySettings] = useState({
    kellyFraction: 0.5, // Half-Kelly for safety
    pyramidingEnabled: true,
    ma200FilterEnabled: true,
    asymmetricFilterEnabled: true,
    minRiskReward: 2.0,
    seykotaStopEnabled: true,
    maxPositionSize: 0.25, // Max 25% per position
    compoundingEnabled: true
  });

  // ==================== ADVANCED RISK MANAGEMENT STATE ====================
  const [riskManagement, setRiskManagement] = useState({
    // Daily Loss Circuit Breaker
    dailyLossLimit: 0.05, // 5% max daily loss
    dailyPnL: 0,
    dailyStartBalance: 20,
    lastDayReset: new Date().toDateString(),
    tradingPaused: false,
    pauseReason: '',

    // Consecutive Loss Protection
    consecutiveLosses: 0,
    maxConsecutiveLosses: 3,
    cooldownMinutes: 30,
    cooldownUntil: null,

    // Position Limits
    maxOpenPositions: 5,
    maxCorrelatedExposure: 0.40, // Max 40% in correlated assets

    // Slippage & Spread Settings
    slippagePercent: 0.05, // 0.05% base slippage
    spreadMultiplier: 1.5, // Additional slippage in high volatility

    // Value at Risk
    var95: 0,
    var99: 0,
    maxDrawdown: 0,
    currentDrawdown: 0
  });

  // Liquidity data for position sizing
  const [liquidityData, setLiquidityData] = useState({});

  // Notification preferences
  const [notifications, setNotifications] = useState({
    desktopEnabled: true,
    soundEnabled: true,
    criticalAlertsOnly: false,
    lastNotification: null
  });

  // ==================== ADVANCED SIMULATION STATE ====================
  const [simulationResults, setSimulationResults] = useState(null);
  const [isSimulating, setIsSimulating] = useState(false);
  const [simulationConfig, setSimulationConfig] = useState({
    monteCarloIterations: 1000,
    walkForwardTrainDays: 180,
    walkForwardTestDays: 30,
    includeSlippage: true,
    includeFees: true,
    confidenceLevel: 95
  });
  const [statisticalTests, setStatisticalTests] = useState(null);
  const [performanceReport, setPerformanceReport] = useState(null);
  const [proStrategyStats, setProStrategyStats] = useState({
    kellySize: 0,
    ma200Status: { aboveMA: true, distance: 0 },
    riskRewardRatio: 0,
    turtleSignal: 'NONE',
    vcpDetected: false,
    fearGreedScore: 50,
    pyramidLevel: 0,
    rulesCheck: { violations: [], recommendations: [] }
  });

  // Analytics
  const [equityCurve, setEquityCurve] = useState([{ time: Date.now(), value: 20 }]);
  const [indicators, setIndicators] = useState({ rsi: 50, macd: { macd: 0, signal: 0, histogram: 0 }, bollinger: { upper: 0, middle: 0, lower: 0 }, sma20: 0, sma50: 0 });

  // Refs
  const botIntervalRef = useRef(null);
  const highestPriceRef = useRef(0);
  const dcaCounterRef = useRef(0);

  // ==================== LOGGING ====================
  const addLog = useCallback((message, type = 'info') => {
    const entry = { time: new Date().toLocaleTimeString(), message, type };
    setLogs(prev => [entry, ...prev.slice(0, 99)]);
  }, []);

  // ==================== SOUND ====================
  const playSound = useCallback((type) => {
    if (!settings.soundEnabled) return;
    try {
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.connect(gain);
      gain.connect(ctx.destination);
      osc.frequency.value = type === 'buy' ? 800 : type === 'sell' ? 400 : 600;
      gain.gain.setValueAtTime(0.1, ctx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.2);
      osc.start();
      osc.stop(ctx.currentTime + 0.2);
    } catch (e) {}
  }, [settings.soundEnabled]);

  // ==================== OPENROUTER AI ANALYSIS ====================
  const runAiAnalysis = useCallback(async () => {
    if (!settings.openRouterKey) {
      addLog('Enter OpenRouter API key in settings first', 'error');
      return;
    }

    if (priceHistory.length < 20) {
      addLog('Need more price data. Connect to Kraken API first.', 'error');
      return;
    }

    setIsAiAnalyzing(true);
    addLog(`ðŸ§  Running AI analysis with ${settings.aiModel}...`, 'info');

    try {
      const aiEngine = new AIAnalysisEngine(settings.openRouterKey, settings.aiModel);

      const marketData = {
        pair: selectedPair,
        price: prices[selectedPair]?.price || priceHistory[priceHistory.length - 1],
        priceHistory: priceHistory.slice(-100),
        indicators: indicators,
        regime: marketRegime,
        patterns: detectedPatterns,
        sentiment: sentiment
      };

      const result = await aiEngine.analyzeMarket(marketData);

      if (result.success && result.analysis) {
        setAiAnalysis(result.analysis);
        setAiHistory(prev => [{
          timestamp: new Date().toISOString(),
          pair: selectedPair,
          analysis: result.analysis
        }, ...prev.slice(0, 19)]);

        // Log the result
        const signal = result.analysis.signal;
        const confidence = result.analysis.confidence;
        addLog(`ðŸ¤– AI Signal: ${signal} (${confidence}% confidence)`, signal === 'BUY' ? 'success' : signal === 'SELL' ? 'error' : 'info');

        if (result.analysis.reasoning) {
          addLog(`ðŸ“Š Reasoning: ${result.analysis.reasoning.slice(0, 100)}...`, 'info');
        }

        // Voice alert if enabled
        if (settings.soundEnabled && signal !== 'HOLD') {
          speakAlert(`AI recommends ${signal} for ${selectedPair} with ${confidence} percent confidence`);
        }
      } else {
        addLog('AI analysis returned no structured data: ' + (result.raw?.slice(0, 100) || result.error), 'warning');
      }
    } catch (error) {
      addLog('AI analysis error: ' + error.message, 'error');
    } finally {
      setIsAiAnalyzing(false);
    }
  }, [settings.openRouterKey, settings.aiModel, settings.soundEnabled, selectedPair, priceHistory, prices, indicators, marketRegime, detectedPatterns, sentiment, addLog]);

  // AI Strategy Improvement
  const runAiStrategyOptimizer = useCallback(async () => {
    if (!settings.openRouterKey) {
      addLog('Enter OpenRouter API key first', 'error');
      return;
    }

    if (trades.length < 5) {
      addLog('Need at least 5 trades for strategy optimization', 'error');
      return;
    }

    setIsAiAnalyzing(true);
    addLog('ðŸ§  Analyzing your trading history...', 'info');

    try {
      const aiEngine = new AIAnalysisEngine(settings.openRouterKey, settings.aiModel);

      const performanceMetrics = {
        winRate: trades.filter(t => t.pnl > 0).length / trades.length * 100,
        profitFactor: trades.filter(t => t.pnl > 0).reduce((s, t) => s + t.pnl, 0) / Math.abs(trades.filter(t => t.pnl < 0).reduce((s, t) => s + t.pnl, 0)) || 0,
        sharpeRatio: 1.5, // Would calculate from returns
        maxDrawdown: Math.min(...trades.map(t => t.pnl)),
        avgWin: trades.filter(t => t.pnl > 0).reduce((s, t) => s + t.pnl, 0) / trades.filter(t => t.pnl > 0).length || 0,
        avgLoss: trades.filter(t => t.pnl < 0).reduce((s, t) => s + t.pnl, 0) / trades.filter(t => t.pnl < 0).length || 0
      };

      const result = await aiEngine.generateStrategy(trades, performanceMetrics);

      if (result.success && result.strategy) {
        addLog('âœ¨ AI Strategy Recommendations:', 'success');
        addLog(`Analysis: ${result.strategy.analysis}`, 'info');

        if (result.strategy.improvements) {
          result.strategy.improvements.forEach(imp => {
            addLog(`ðŸ’¡ ${imp.area}: ${imp.suggestion}`, 'info');
          });
        }

        if (result.strategy.recommended_settings) {
          addLog(`ðŸŽ¯ Recommended: ${result.strategy.recommended_settings.best_strategy} strategy`, 'success');
        }
      } else {
        addLog('Could not generate strategy recommendations', 'warning');
      }
    } catch (error) {
      addLog('Strategy optimization error: ' + error.message, 'error');
    } finally {
      setIsAiAnalyzing(false);
    }
  }, [settings.openRouterKey, settings.aiModel, trades, addLog]);

  // Fetch News Sentiment
  const fetchNewsSentiment = useCallback(async () => {
    addLog('ðŸ“° Fetching crypto news...', 'info');
    const news = await fetchCryptoNews(selectedPair);

    if (news.length > 0) {
      setNewsSentiment({
        score: news.filter(n => n.sentiment === 'positive').length - news.filter(n => n.sentiment === 'negative').length,
        headlines: news,
        lastUpdate: new Date().toISOString()
      });
      addLog(`Found ${news.length} news articles for ${selectedPair}`, 'success');

      // If we have OpenRouter, do deeper analysis
      if (settings.openRouterKey && news.length > 0) {
        const aiEngine = new AIAnalysisEngine(settings.openRouterKey, 'anthropic/claude-3-haiku');
        const newsAnalysis = await aiEngine.analyzeNews(selectedPair, news.map(n => n.title));
        if (newsAnalysis.success) {
          setNewsSentiment(prev => ({ ...prev, aiAnalysis: newsAnalysis.analysis }));
          addLog(`ðŸ¤– News sentiment: ${newsAnalysis.analysis?.trading_bias || 'neutral'}`, 'info');
        }
      }
    } else {
      addLog('No recent news found', 'warning');
    }
  }, [selectedPair, settings.openRouterKey, addLog]);

  // Text-to-speech for voice alerts
  const speakAlert = useCallback((text) => {
    if ('speechSynthesis' in window) {
      const utterance = new SpeechSynthesisUtterance(text);
      utterance.rate = 1.1;
      utterance.pitch = 1;
      utterance.volume = 0.8;
      window.speechSynthesis.speak(utterance);
    }
  }, []);

  // Fetch Fear & Greed Index
  const updateFearGreed = useCallback(async () => {
    addLog('ðŸ“Š Fetching Fear & Greed Index...', 'info');
    const fg = await fetchFearGreedIndex();
    setSocialSentiment(prev => ({
      ...prev,
      fear_greed: fg.value,
      fear_greed_label: fg.classification
    }));
    addLog(`Fear & Greed: ${fg.value} (${fg.classification})`, fg.value < 25 ? 'success' : fg.value > 75 ? 'error' : 'info');
    return fg;
  }, [addLog]);

  // ==================== KRAKEN WEBSOCKET API ====================
  const connectWebSocket = useCallback(() => {
    if (wsRef.current?.readyState === WebSocket.OPEN) {
      addLog('Already connected to Kraken', 'warning');
      return;
    }

    // Close any existing connection
    if (wsRef.current) {
      wsRef.current.close();
      wsRef.current = null;
    }

    setApiStatus('connecting');
    addLog('Connecting to Kraken WebSocket (wss://ws.kraken.com)...');

    try {
      wsRef.current = new WebSocket('wss://ws.kraken.com');

      wsRef.current.onopen = () => {
        setApiStatus('connected');
        addLog('âœ“ Connected to Kraken WebSocket', 'success');
        playSound('buy');

        // Subscribe to ticker for pairs (convert BTC to XBT for Kraken)
        const krakenPairs = TRADING_PAIRS.slice(0, 20).map(p => {
          if (p === 'BTC/USD') return 'XBT/USD';
          return p;
        });

        wsRef.current.send(JSON.stringify({
          event: 'subscribe',
          pair: krakenPairs,
          subscription: { name: 'ticker' }
        }));

        addLog(`Subscribed to ${krakenPairs.length} pairs`, 'success');
      };

      wsRef.current.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);

          // Handle ticker updates
          if (Array.isArray(data) && data.length >= 4) {
            const [channelId, tickerData, channelName, pairName] = data;

            if (channelName === 'ticker' && tickerData) {
              let normalizedPair = pairName.replace('XBT', 'BTC');

              const price = parseFloat(tickerData.c?.[0] || tickerData.c || 0);
              const open = parseFloat(tickerData.o?.[0] || tickerData.o || price);
              const change24h = open > 0 ? ((price - open) / open * 100) : 0;

              setPrices(prev => ({
                ...prev,
                [normalizedPair]: {
                  price,
                  change24h,
                  high24h: parseFloat(tickerData.h?.[1] || tickerData.h || price),
                  low24h: parseFloat(tickerData.l?.[1] || tickerData.l || price),
                  volume: parseFloat(tickerData.v?.[1] || tickerData.v || 0),
                  bid: parseFloat(tickerData.b?.[0] || price),
                  ask: parseFloat(tickerData.a?.[0] || price)
                }
              }));

              // Update price history
              if (!priceHistoryRef.current[normalizedPair]) {
                priceHistoryRef.current[normalizedPair] = [];
              }
              priceHistoryRef.current[normalizedPair].push(price);
              if (priceHistoryRef.current[normalizedPair].length > 1000) {
                priceHistoryRef.current[normalizedPair].shift();
              }
              setPriceHistory({ ...priceHistoryRef.current });
            }
          }

          // Handle subscription status
          if (data.event === 'subscriptionStatus') {
            if (data.status === 'subscribed') {
              addLog(`Subscribed: ${data.channelName} - ${data.pair}`, 'info');
            } else if (data.status === 'error') {
              addLog(`Subscription error: ${data.errorMessage}`, 'error');
            }
          }
        } catch (e) {
          // Ignore parse errors for heartbeats
        }
      };

      wsRef.current.onerror = (error) => {
        addLog('WebSocket error - check browser console for details', 'error');
        console.error('Kraken WebSocket Error:', error);
        setApiStatus('error');
      };

      wsRef.current.onclose = (event) => {
        if (event.wasClean) {
          addLog(`Disconnected from Kraken (code: ${event.code})`, 'warning');
        } else {
          addLog(`Connection lost unexpectedly (code: ${event.code})`, 'error');
        }
        setApiStatus('disconnected');
      };
    } catch (e) {
      addLog(`Connection failed: ${e.message}`, 'error');
      console.error('Kraken Connection Error:', e);
      setApiStatus('error');
    }
  }, [addLog, playSound]);

  const disconnectWebSocket = useCallback(() => {
    if (wsRef.current) {
      wsRef.current.close();
      wsRef.current = null;
    }
    if (binanceWsRef.current) {
      binanceWsRef.current.close();
      binanceWsRef.current = null;
    }
    if (coinbaseWsRef.current) {
      coinbaseWsRef.current.close();
      coinbaseWsRef.current = null;
    }
    if (pollingIntervalRef.current) {
      clearInterval(pollingIntervalRef.current);
      pollingIntervalRef.current = null;
    }
    setApiStatus('disconnected');
    addLog(`Disconnected from ${EXCHANGES[activeExchange]?.name || 'exchange'}`);
  }, [addLog, activeExchange]);

  // ==================== BINANCE WEBSOCKET API ====================
  const connectBinance = useCallback(() => {
    if (binanceWsRef.current?.readyState === WebSocket.OPEN) {
      addLog('Already connected to Binance', 'warning');
      return;
    }

    setApiStatus('connecting');
    setActiveExchange('binance');
    addLog('ðŸŸ¡ Connecting to Binance WebSocket...');

    try {
      // Subscribe to multiple tickers
      const symbols = TRADING_PAIRS.slice(0, 20).map(p => toBinanceSymbol(p.replace('/USD', '/USDT')) + '@ticker').join('/');
      binanceWsRef.current = new WebSocket(`wss://stream.binance.com:9443/ws/${symbols}`);

      binanceWsRef.current.onopen = () => {
        setApiStatus('connected');
        addLog('âœ“ Connected to Binance WebSocket', 'success');
        playSound('buy');
      };

      binanceWsRef.current.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);

          if (data.e === '24hrTicker') {
            // Convert BTCUSDT back to BTC/USD format
            let pair = data.s.replace('USDT', '/USD');
            pair = pair.slice(0, -4) + '/' + pair.slice(-3);

            const price = parseFloat(data.c);
            const change24h = parseFloat(data.P);

            setPrices(prev => ({
              ...prev,
              [pair]: {
                price,
                change24h,
                high24h: parseFloat(data.h),
                low24h: parseFloat(data.l),
                volume: parseFloat(data.q),
                bid: parseFloat(data.b),
                ask: parseFloat(data.a)
              }
            }));

            // Update price history
            if (!priceHistoryRef.current[pair]) {
              priceHistoryRef.current[pair] = [];
            }
            priceHistoryRef.current[pair].push(price);
            if (priceHistoryRef.current[pair].length > 1000) {
              priceHistoryRef.current[pair].shift();
            }
          }
        } catch (e) {}
      };

      binanceWsRef.current.onerror = (error) => {
        addLog('Binance WebSocket error', 'error');
      };

      binanceWsRef.current.onclose = () => {
        if (apiStatus === 'connected' && activeExchange === 'binance') {
          addLog('Binance connection closed, reconnecting...', 'warning');
          setTimeout(connectBinance, 3000);
        }
      };
    } catch (error) {
      addLog('Failed to connect to Binance: ' + error.message, 'error');
      setApiStatus('error');
    }
  }, [addLog, playSound, apiStatus, activeExchange]);

  // ==================== COINBASE WEBSOCKET API ====================
  const connectCoinbase = useCallback(() => {
    if (coinbaseWsRef.current?.readyState === WebSocket.OPEN) {
      addLog('Already connected to Coinbase', 'warning');
      return;
    }

    setApiStatus('connecting');
    setActiveExchange('coinbase');
    addLog('ðŸ”µ Connecting to Coinbase WebSocket...');

    try {
      coinbaseWsRef.current = new WebSocket('wss://ws-feed.exchange.coinbase.com');

      coinbaseWsRef.current.onopen = () => {
        setApiStatus('connected');
        addLog('âœ“ Connected to Coinbase WebSocket', 'success');
        playSound('buy');

        // Subscribe to ticker
        const productIds = TRADING_PAIRS.slice(0, 15).map(p => toCoinbaseSymbol(p));
        coinbaseWsRef.current.send(JSON.stringify({
          type: 'subscribe',
          product_ids: productIds,
          channels: ['ticker']
        }));

        addLog(`Subscribed to ${productIds.length} Coinbase pairs`, 'success');
      };

      coinbaseWsRef.current.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);

          if (data.type === 'ticker') {
            const pair = data.product_id.replace('-', '/');
            const price = parseFloat(data.price);

            setPrices(prev => ({
              ...prev,
              [pair]: {
                price,
                change24h: ((price - parseFloat(data.open_24h)) / parseFloat(data.open_24h) * 100) || 0,
                high24h: parseFloat(data.high_24h),
                low24h: parseFloat(data.low_24h),
                volume: parseFloat(data.volume_24h),
                bid: parseFloat(data.best_bid),
                ask: parseFloat(data.best_ask)
              }
            }));

            // Update price history
            if (!priceHistoryRef.current[pair]) {
              priceHistoryRef.current[pair] = [];
            }
            priceHistoryRef.current[pair].push(price);
            if (priceHistoryRef.current[pair].length > 1000) {
              priceHistoryRef.current[pair].shift();
            }
          }
        } catch (e) {}
      };

      coinbaseWsRef.current.onerror = () => {
        addLog('Coinbase WebSocket error', 'error');
      };

      coinbaseWsRef.current.onclose = () => {
        if (apiStatus === 'connected' && activeExchange === 'coinbase') {
          addLog('Coinbase connection closed, reconnecting...', 'warning');
          setTimeout(connectCoinbase, 3000);
        }
      };
    } catch (error) {
      addLog('Failed to connect to Coinbase: ' + error.message, 'error');
      setApiStatus('error');
    }
  }, [addLog, playSound, apiStatus, activeExchange]);

  // Smart connect based on selected exchange
  const connectToExchange = useCallback((exchange) => {
    disconnectWebSocket();

    switch (exchange) {
      case 'binance':
        connectBinance();
        break;
      case 'coinbase':
        connectCoinbase();
        break;
      case 'kraken':
      default:
        connectWebSocket();
        break;
    }
  }, [disconnectWebSocket, connectBinance, connectCoinbase, connectWebSocket]);

  // Polling interval ref for REST API fallback
  const pollingIntervalRef = useRef(null);

  // ==================== REST API FALLBACK (When WebSocket fails) ====================
  const connectViaRestAPI = useCallback(async () => {
    setApiStatus('connecting');
    addLog('Connecting via REST API (polling mode)...');

    const fetchPrices = async () => {
      try {
        // Fetch ticker for major pairs
        const pairs = ['XXBTZUSD', 'XETHZUSD', 'SOLUSD', 'XRPUSD', 'DOGEUSD'].join(',');
        const url = `https://api.kraken.com/0/public/Ticker?pair=${pairs}`;

        // Try with allorigins CORS proxy (most reliable)
        const response = await fetch(`https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`);
        const data = await response.json();

        if (data.error && data.error.length > 0) {
          throw new Error(data.error[0]);
        }

        // Map Kraken pairs back to our format
        const pairMapping = {
          'XXBTZUSD': 'BTC/USD', 'XETHZUSD': 'ETH/USD', 'SOLUSD': 'SOL/USD',
          'XXRPZUSD': 'XRP/USD', 'XRPUSD': 'XRP/USD', 'XDGUSD': 'DOGE/USD', 'DOGEUSD': 'DOGE/USD'
        };

        Object.entries(data.result || {}).forEach(([krakenPair, tickerData]) => {
          const ourPair = pairMapping[krakenPair];
          if (!ourPair) return;

          const price = parseFloat(tickerData.c?.[0] || 0);
          const open = parseFloat(tickerData.o || price);
          const change24h = open > 0 ? ((price - open) / open * 100) : 0;

          setPrices(prev => ({
            ...prev,
            [ourPair]: {
              price,
              change24h,
              high24h: parseFloat(tickerData.h?.[1] || price),
              low24h: parseFloat(tickerData.l?.[1] || price),
              volume: parseFloat(tickerData.v?.[1] || 0),
              bid: parseFloat(tickerData.b?.[0] || price),
              ask: parseFloat(tickerData.a?.[0] || price)
            }
          }));

          // Update price history
          if (!priceHistoryRef.current[ourPair]) {
            priceHistoryRef.current[ourPair] = [];
          }
          priceHistoryRef.current[ourPair].push(price);
          if (priceHistoryRef.current[ourPair].length > 1000) {
            priceHistoryRef.current[ourPair].shift();
          }
        });

        setPriceHistory({ ...priceHistoryRef.current });

        if (apiStatus !== 'connected') {
          setApiStatus('connected');
          addLog('âœ“ Connected via REST API (polling every 5s)', 'success');
          playSound('buy');
        }
      } catch (e) {
        console.error('REST API fetch error:', e);
        if (apiStatus === 'connected') {
          addLog('REST API error: ' + e.message, 'error');
        }
      }
    };

    // Initial fetch
    await fetchPrices();

    // Poll every 5 seconds
    pollingIntervalRef.current = setInterval(fetchPrices, 5000);
  }, [apiStatus, addLog, playSound]);

  // ==================== SMART CONNECT (Try WebSocket, fallback to REST) ====================
  const smartConnect = useCallback(async () => {
    setApiStatus('connecting');
    addLog('Attempting to connect to Kraken...');

    // First try WebSocket
    try {
      const ws = new WebSocket('wss://ws.kraken.com');

      const wsPromise = new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
          ws.close();
          reject(new Error('WebSocket timeout'));
        }, 5000);

        ws.onopen = () => {
          clearTimeout(timeout);
          resolve(ws);
        };
        ws.onerror = () => {
          clearTimeout(timeout);
          reject(new Error('WebSocket failed'));
        };
      });

      wsRef.current = await wsPromise;
      setApiStatus('connected');
      addLog('âœ“ Connected via WebSocket (real-time)', 'success');
      playSound('buy');

      // Subscribe to ticker
      const krakenPairs = TRADING_PAIRS.slice(0, 20).map(p => p === 'BTC/USD' ? 'XBT/USD' : p);
      wsRef.current.send(JSON.stringify({
        event: 'subscribe',
        pair: krakenPairs,
        subscription: { name: 'ticker' }
      }));

      wsRef.current.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          if (Array.isArray(data) && data.length >= 4) {
            const [, tickerData, channelName, pairName] = data;
            if (channelName === 'ticker' && tickerData) {
              const normalizedPair = pairName.replace('XBT', 'BTC');
              const price = parseFloat(tickerData.c?.[0] || 0);
              const open = parseFloat(tickerData.o?.[0] || price);

              setPrices(prev => ({
                ...prev,
                [normalizedPair]: {
                  price,
                  change24h: open > 0 ? ((price - open) / open * 100) : 0,
                  high24h: parseFloat(tickerData.h?.[1] || price),
                  low24h: parseFloat(tickerData.l?.[1] || price),
                  volume: parseFloat(tickerData.v?.[1] || 0),
                  bid: parseFloat(tickerData.b?.[0] || price),
                  ask: parseFloat(tickerData.a?.[0] || price)
                }
              }));

              if (!priceHistoryRef.current[normalizedPair]) {
                priceHistoryRef.current[normalizedPair] = [];
              }
              priceHistoryRef.current[normalizedPair].push(price);
              if (priceHistoryRef.current[normalizedPair].length > 1000) {
                priceHistoryRef.current[normalizedPair].shift();
              }
              setPriceHistory({ ...priceHistoryRef.current });
            }
          }
        } catch (e) {}
      };

      wsRef.current.onclose = () => {
        setApiStatus('disconnected');
        addLog('WebSocket disconnected', 'warning');
      };

    } catch (wsError) {
      addLog('WebSocket unavailable, trying REST API...', 'warning');
      // Fallback to REST API polling
      await connectViaRestAPI();
    }
  }, [addLog, playSound, connectViaRestAPI]);

  // ==================== FETCH HISTORICAL DATA (REAL KRAKEN API) ====================
  const fetchHistoricalData = useCallback(async (pair = selectedPair, tf = timeframe) => {
    const krakenPair = KRAKEN_PAIRS[pair];
    if (!krakenPair) {
      addLog(`Unknown pair mapping for ${pair}`, 'error');
      return null;
    }

    setDataStatus('loading');
    addLog(`Fetching historical data for ${pair}...`);

    try {
      const intervalMinutes = TIMEFRAMES[tf]?.interval || 60;

      // Calculate since timestamp based on backtest config
      let since;
      if (backtestConfig.useCustomDate && backtestConfig.customStartDate) {
        since = Math.floor(new Date(backtestConfig.customStartDate).getTime() / 1000);
      } else {
        const hoursAgo = backtestConfig.hoursBack || 36;
        since = Math.floor((Date.now() - hoursAgo * 60 * 60 * 1000) / 1000);
      }

      const krakenUrl = `https://api.kraken.com/0/public/OHLC?pair=${krakenPair}&interval=${intervalMinutes}&since=${since}`;

      // Try direct first (works for most), then corsproxy as fallback
      const corsProxies = [
        '', // Direct (no proxy)
        'https://corsproxy.io/?'
      ];

      let response = null;
      let json = null;

      for (const proxy of corsProxies) {
        try {
          const url = proxy ? `${proxy}${encodeURIComponent(krakenUrl)}` : krakenUrl;
          addLog(`Trying ${proxy ? 'proxy' : 'direct'}...`, 'info');

          response = await fetch(url);

          if (response.ok) {
            json = await response.json();
            if (!json.error || json.error.length === 0) {
              addLog(`âœ“ Connected via ${proxy ? 'CORS proxy' : 'direct'}`, 'success');
              break;
            }
          }
        } catch (proxyError) {
          // Try next proxy
          continue;
        }
      }

      if (!json) {
        throw new Error('All connection methods failed - check internet connection');
      }

      if (json.error && json.error.length > 0) {
        throw new Error(json.error.join(', '));
      }

      const resultKey = Object.keys(json.result).find(k => k !== 'last');
      if (!resultKey) {
        throw new Error('No data key found in response');
      }

      const ohlcData = json.result[resultKey];

      if (!ohlcData || ohlcData.length === 0) {
        throw new Error('No candle data returned');
      }

      const formattedData = ohlcData.map(candle => ({
        time: candle[0] * 1000,
        timestamp: candle[0],
        open: parseFloat(candle[1]),
        high: parseFloat(candle[2]),
        low: parseFloat(candle[3]),
        close: parseFloat(candle[4]),
        vwap: parseFloat(candle[5]),
        volume: parseFloat(candle[6]),
        count: parseInt(candle[7])
      }));

      // Filter by end date if custom
      let filteredData = formattedData;
      if (backtestConfig.useCustomDate && backtestConfig.customEndDate) {
        const endTime = new Date(backtestConfig.customEndDate).getTime();
        filteredData = formattedData.filter(c => c.time <= endTime);
      }

      setHistoricalData(prev => ({ ...prev, [pair]: filteredData }));

      const startDate = new Date(filteredData[0].time).toLocaleString();
      const endDate = new Date(filteredData[filteredData.length - 1].time).toLocaleString();

      setDataStatus(`âœ“ Loaded ${filteredData.length} candles (${startDate} â†’ ${endDate})`);
      addLog(`âœ“ Loaded ${filteredData.length} candles for ${pair}`, 'success');

      return filteredData;
    } catch (e) {
      setDataStatus(`Error: ${e.message}`);
      addLog(`Failed to fetch ${pair}: ${e.message}`, 'error');
      return null;
    }
  }, [selectedPair, timeframe, backtestConfig, addLog]);

  // ==================== REAL BACKTESTING ENGINE ====================
  const runBacktest = useCallback(async () => {
    // Get or fetch historical data
    let data = historicalData[selectedPair];
    if (!data || data.length < 50) {
      addLog('Fetching historical data for backtest...', 'info');
      data = await fetchHistoricalData(selectedPair, timeframe);
    }

    if (!data || data.length < 50) {
      addLog('Insufficient data for backtest (need at least 50 candles)', 'error');
      return;
    }

    setIsBacktesting(true);
    setBacktestResults(null);
    setBacktestProgress(0);
    addLog(`Starting backtest with ${settings.strategy} strategy on ${data.length} candles...`, 'info');

    // Run backtest asynchronously to not block UI
    setTimeout(async () => {
      const closes = data.map(c => c.close);
      let btBalance = initialBalance;
      let btPosition = null;
      let btTrades = [];
      let wins = 0, losses = 0;
      let maxDrawdown = 0, peak = initialBalance;
      let equityHistory = [];
      let trailingHigh = 0;

      for (let i = 50; i < closes.length; i++) {
        // Update progress every 10 candles
        if (i % 10 === 0) {
          setBacktestProgress(Math.round((i / closes.length) * 100));
          await new Promise(r => setTimeout(r, 1)); // Allow UI update
        }

        const price = closes[i];
        const priceSlice = closes.slice(0, i + 1);
        const rsi = calculateRSI(priceSlice);
        const macd = calculateMACD(priceSlice);
        const bb = calculateBollingerBands(priceSlice);
        const sma20 = calculateSMA(priceSlice, 20);
        const sma50 = calculateSMA(priceSlice, 50);

        // Entry logic (no position)
        if (!btPosition) {
          let shouldBuy = false;
          let reason = '';

          switch (settings.strategy) {
            case 'momentum':
              if (rsi > 30 && rsi < 70 && macd.histogram > 0 && price > sma20) {
                shouldBuy = true;
                reason = 'Momentum signal';
              }
              break;
            case 'meanReversion':
              if (rsi < 30 && price <= bb.lower) {
                shouldBuy = true;
                reason = 'Mean reversion (oversold)';
              }
              break;
            case 'rsi':
              if (rsi < 25) {
                shouldBuy = true;
                reason = `RSI oversold (${rsi.toFixed(0)})`;
              }
              break;
            case 'macd':
              if (macd.histogram > 0 && macd.macd > macd.signal) {
                shouldBuy = true;
                reason = 'MACD bullish crossover';
              }
              break;
            case 'grid':
              const gridSpacing = settings.gridSpacing / 100;
              for (let g = 1; g <= settings.gridLevels; g++) {
                const level = closes[50] * (1 - gridSpacing * g);
                if (price <= level && price > level * 0.99) {
                  shouldBuy = true;
                  reason = `Grid level ${g}`;
                  break;
                }
              }
              break;
            case 'dca':
              if (i % settings.dcaInterval === 0) {
                shouldBuy = true;
                reason = 'DCA interval';
              }
              break;
            case 'scalp':
              const sma5 = calculateSMA(priceSlice, 5);
              const sma15 = calculateSMA(priceSlice, 15);
              if (sma5 > sma15) {
                shouldBuy = true;
                reason = 'Scalp entry';
              }
              break;
          }

          if (shouldBuy && btBalance > 0) {
            const amount = btBalance * (settings.tradeSize / 100);
            const qty = amount / price;
            const cost = amount * 1.0026; // Include 0.26% Kraken fee

            if (cost <= btBalance) {
              btBalance -= cost;
              btPosition = { entry: price, qty, cost, high: price };
              trailingHigh = price;

              btTrades.push({
                type: 'buy',
                price,
                amount: cost,
                reason,
                time: data[i].time
              });
            }
          }
        }

        // Exit logic (has position)
        if (btPosition) {
          const pnlPct = ((price - btPosition.entry) / btPosition.entry) * 100;

          // Update trailing high
          if (price > trailingHigh) trailingHigh = price;

          let shouldSell = false;
          let exitReason = '';

          // Trailing stop
          if (settings.trailingStop && pnlPct > 0) {
            const trailStop = trailingHigh * (1 - settings.trailingPercent / 100);
            if (price <= trailStop) {
              shouldSell = true;
              exitReason = 'Trailing Stop';
            }
          }

          // Fixed stop loss
          if (!shouldSell && pnlPct <= -settings.stopLoss) {
            shouldSell = true;
            exitReason = 'Stop Loss';
          }

          // Take profit
          if (!shouldSell && pnlPct >= settings.takeProfit) {
            shouldSell = true;
            exitReason = 'Take Profit';
          }

          // Strategy-specific exits
          if (!shouldSell) {
            switch (settings.strategy) {
              case 'rsi':
                if (rsi > 70) { shouldSell = true; exitReason = 'RSI Overbought'; }
                break;
              case 'macd':
                if (macd.histogram < 0) { shouldSell = true; exitReason = 'MACD Bearish'; }
                break;
            }
          }

          if (shouldSell) {
            const value = btPosition.qty * price * 0.9974; // Include fee
            const pnl = value - btPosition.cost;
            btBalance += value;

            if (pnl > 0) wins++;
            else losses++;

            btTrades.push({
              type: 'sell',
              price,
              amount: value,
              pnl,
              pnlPct: (pnl / btPosition.cost) * 100,
              reason: exitReason,
              time: data[i].time
            });

            btPosition = null;
            trailingHigh = 0;
          }
        }

        // Track equity
        const equity = btBalance + (btPosition ? btPosition.qty * price : 0);
        equityHistory.push({ time: data[i].time, equity });

        // Track max drawdown
        if (equity > peak) peak = equity;
        const dd = ((peak - equity) / peak) * 100;
        if (dd > maxDrawdown) maxDrawdown = dd;
      }

      // Close any remaining position at end
      if (btPosition) {
        const finalPrice = closes[closes.length - 1];
        const value = btPosition.qty * finalPrice * 0.9974;
        const pnl = value - btPosition.cost;
        btBalance += value;

        if (pnl > 0) wins++;
        else losses++;

        btTrades.push({
          type: 'sell',
          price: finalPrice,
          amount: value,
          pnl,
          pnlPct: (pnl / btPosition.cost) * 100,
          reason: 'End of backtest',
          time: data[data.length - 1].time
        });
      }

      // Calculate final metrics
      const finalEquity = btBalance;
      const totalReturn = ((finalEquity - initialBalance) / initialBalance) * 100;
      const sellTrades = btTrades.filter(t => t.type === 'sell');
      const winRate = sellTrades.length > 0 ? (wins / sellTrades.length) * 100 : 0;
      const avgWin = wins > 0 ? sellTrades.filter(t => t.pnl > 0).reduce((a, t) => a + t.pnl, 0) / wins : 0;
      const avgLoss = losses > 0 ? Math.abs(sellTrades.filter(t => t.pnl < 0).reduce((a, t) => a + t.pnl, 0) / losses) : 0;
      const profitFactor = avgLoss > 0 ? (avgWin * wins) / (avgLoss * losses) : (avgWin > 0 ? Infinity : 0);

      const results = {
        totalReturn,
        finalEquity,
        trades: btTrades.length,
        wins,
        losses,
        winRate,
        maxDrawdown,
        profitFactor,
        avgWin,
        avgLoss,
        tradeList: btTrades,
        equityHistory: equityHistory.filter((_, i) => i % Math.max(1, Math.floor(equityHistory.length / 100)) === 0),
        dataPoints: closes.length,
        period: {
          start: new Date(data[0].time).toLocaleString(),
          end: new Date(data[data.length - 1].time).toLocaleString(),
          candles: data.length
        }
      };

      setBacktestResults(results);
      setBacktestProgress(100);
      setIsBacktesting(false);

      addLog(
        `âœ“ Backtest complete: ${totalReturn >= 0 ? '+' : ''}${totalReturn.toFixed(2)}% return | ${sellTrades.length} trades | ${winRate.toFixed(0)}% win rate`,
        totalReturn >= 0 ? 'success' : 'error'
      );
    }, 100);
  }, [historicalData, selectedPair, timeframe, settings, initialBalance, fetchHistoricalData, addLog]);

  // ==================== MULTI-PAIR SCANNER ====================
  const runScanner = useCallback(() => {
    setIsScanning(true);
    setScanResults([]);
    addLog('Scanning all pairs for signals...');

    const results = [];

    TRADING_PAIRS.slice(0, 20).forEach(pair => {
      const history = priceHistoryRef.current[pair];
      if (!history || history.length < 20) return;

      const price = prices[pair]?.price || history[history.length - 1];
      const rsi = calculateRSI(history);
      const macd = calculateMACD(history);
      const change = prices[pair]?.change24h || 0;

      let signal = null;
      let strength = 0;
      let reasons = [];

      if (rsi < 30 && macd.histogram > 0) {
        signal = 'STRONG BUY';
        strength = 90;
        reasons.push('RSI oversold + MACD bullish');
      } else if (rsi < 35) {
        signal = 'BUY';
        strength = 70;
        reasons.push(`RSI oversold (${rsi.toFixed(0)})`);
      } else if (rsi > 70 && macd.histogram < 0) {
        signal = 'STRONG SELL';
        strength = 90;
        reasons.push('RSI overbought + MACD bearish');
      } else if (rsi > 65) {
        signal = 'SELL';
        strength = 70;
        reasons.push(`RSI overbought (${rsi.toFixed(0)})`);
      }

      if (signal) {
        results.push({
          pair,
          signal,
          strength,
          rsi: rsi.toFixed(0),
          change: change.toFixed(2),
          price,
          reasons: reasons.join(', ')
        });
      }
    });

    results.sort((a, b) => b.strength - a.strength);
    setScanResults(results.slice(0, 10));
    setIsScanning(false);
    addLog(`âœ“ Scanner: ${results.length} signals found`, 'success');
  }, [prices, addLog]);

  // ==================== AI OPTIMIZER ====================
  const runOptimizer = useCallback(async () => {
    let data = historicalData[selectedPair];
    if (!data || data.length < 100) {
      addLog('Fetching data for optimizer...', 'info');
      data = await fetchHistoricalData(selectedPair, timeframe);
    }

    if (!data || data.length < 100) {
      addLog('Need more data for optimization (100+ candles)', 'error');
      return;
    }

    setIsOptimizing(true);
    setOptimizerResults(null);
    addLog('Running AI parameter optimization...');

    setTimeout(() => {
      const results = [];
      const closes = data.map(c => c.close);

      // Test different SL/TP combinations
      [1, 2, 3, 4, 5].forEach(sl => {
        [2, 3, 4, 5, 6, 8, 10].forEach(tp => {
          if (tp <= sl) return; // Skip invalid combos

          let bal = initialBalance, pos = null, w = 0, l = 0;

          for (let i = 50; i < closes.length; i++) {
            const price = closes[i];
            const rsi = calculateRSI(closes.slice(0, i + 1));

            // Simple RSI strategy for testing
            if (!pos && rsi < 30) {
              const amt = bal * 0.5;
              pos = { entry: price, qty: amt / price, cost: amt };
              bal -= amt;
            }

            if (pos) {
              const pnl = ((price - pos.entry) / pos.entry) * 100;
              if (pnl <= -sl || pnl >= tp) {
                const value = pos.qty * price;
                bal += value;
                if (pnl > 0) w++; else l++;
                pos = null;
              }
            }
          }

          // Close remaining position
          if (pos) {
            bal += pos.qty * closes[closes.length - 1];
          }

          const ret = ((bal - initialBalance) / initialBalance) * 100;
          const wr = (w + l) > 0 ? (w / (w + l)) * 100 : 0;

          results.push({
            stopLoss: sl,
            takeProfit: tp,
            return: ret.toFixed(1),
            winRate: wr.toFixed(0),
            trades: w + l,
            sharpe: sl > 0 ? (ret / sl).toFixed(2) : '0'
          });
        });
      });

      results.sort((a, b) => parseFloat(b.return) - parseFloat(a.return));
      setOptimizerResults(results.slice(0, 5));
      setIsOptimizing(false);
      addLog('âœ“ Optimization complete', 'success');
    }, 1000);
  }, [historicalData, selectedPair, timeframe, initialBalance, fetchHistoricalData, addLog]);

  // ==================== LIVE TRADING ====================
  const executeTrade = useCallback((side, pair, reason, price = null) => {
    const tradePair = pair || selectedPair;
    const currentPrice = price || prices[tradePair]?.price;
    if (!currentPrice) return;

    const time = new Date().toISOString();
    const fee = 0.0026;

    if (side === 'buy' && !positions[tradePair]) {
      const amount = balance * (settings.tradeSize / 100);
      const qty = amount / currentPrice;
      const cost = amount * (1 + fee);

      if (cost > balance) {
        addLog('Insufficient balance', 'error');
        return;
      }

      setPositions(prev => ({
        ...prev,
        [tradePair]: { entry: currentPrice, quantity: qty, cost, time }
      }));
      setBalance(prev => prev - cost);
      highestPriceRef.current = currentPrice;

      setTrades(prev => [...prev, { time, side: 'BUY', pair: tradePair, price: currentPrice, quantity: qty, fee: amount * fee, reason }]);
      addLog(`BUY ${qty.toFixed(6)} ${tradePair} @ $${formatPrice(currentPrice, tradePair)} â€” ${reason}`, 'success');
      playSound('buy');

    } else if (side === 'sell' && positions[tradePair]) {
      const pos = positions[tradePair];
      const value = pos.quantity * currentPrice;
      const netValue = value * (1 - fee);
      const pnl = netValue - pos.cost;
      const pnlPct = (pnl / pos.cost) * 100;

      setBalance(prev => prev + netValue);
      setPositions(prev => {
        const newPos = { ...prev };
        delete newPos[tradePair];
        return newPos;
      });
      highestPriceRef.current = 0;

      setTrades(prev => [...prev, { time, side: 'SELL', pair: tradePair, price: currentPrice, quantity: pos.quantity, fee: value * fee, pnl, pnlPct, reason }]);
      addLog(`SELL @ $${formatPrice(currentPrice, tradePair)} | P&L: $${pnl.toFixed(2)} (${pnlPct.toFixed(1)}%) â€” ${reason}`, pnl >= 0 ? 'success' : 'error');
      playSound(pnl >= 0 ? 'sell' : 'error');
    }
  }, [prices, selectedPair, positions, balance, settings, playSound, addLog]);

  // ==================== BOT STRATEGY LOOP ====================
  const runStrategy = useCallback(() => {
    const price = prices[selectedPair]?.price;
    const history = priceHistoryRef.current[selectedPair];
    if (!price || !history || history.length < 20) return;

    const rsi = calculateRSI(history);
    const macd = calculateMACD(history);
    const bb = calculateBollingerBands(history);
    const sma20 = calculateSMA(history, 20);

    // Check existing position
    const position = positions[selectedPair];
    if (position) {
      const pnlPct = ((price - position.entry) / position.entry) * 100;

      // Update trailing high
      if (price > highestPriceRef.current) {
        highestPriceRef.current = price;
      }

      // Trailing stop
      if (settings.trailingStop && pnlPct > 0) {
        const trailStop = highestPriceRef.current * (1 - settings.trailingPercent / 100);
        if (price <= trailStop) {
          executeTrade('sell', selectedPair, 'Trailing Stop');
          return;
        }
      }

      // Fixed stops
      if (pnlPct <= -settings.stopLoss) {
        executeTrade('sell', selectedPair, 'Stop Loss');
        return;
      }
      if (pnlPct >= settings.takeProfit) {
        executeTrade('sell', selectedPair, 'Take Profit');
        return;
      }

      // Strategy exits
      if (settings.strategy === 'rsi' && rsi > 70) {
        executeTrade('sell', selectedPair, 'RSI Exit');
        return;
      }
      if (settings.strategy === 'macd' && macd.histogram < 0) {
        executeTrade('sell', selectedPair, 'MACD Exit');
        return;
      }
    }

    // Entry signals (no position)
    if (!position && balance > 1) {
      let shouldBuy = false;
      let reason = '';

      switch (settings.strategy) {
        case 'momentum':
          if (rsi > 30 && rsi < 70 && macd.histogram > 0 && price > sma20) {
            shouldBuy = true;
            reason = 'Momentum';
          }
          break;
        case 'meanReversion':
          if (rsi < 30 && price <= bb.lower) {
            shouldBuy = true;
            reason = 'Reversal';
          }
          break;
        case 'rsi':
          if (rsi < 25) {
            shouldBuy = true;
            reason = 'RSI Oversold';
          }
          break;
        case 'macd':
          if (macd.histogram > 0 && macd.macd > macd.signal) {
            shouldBuy = true;
            reason = 'MACD Cross';
          }
          break;
        case 'grid':
          const spacing = settings.gridSpacing / 100;
          const basePrice = BASE_PRICES[selectedPair] || price;
          for (let i = 1; i <= settings.gridLevels; i++) {
            const level = basePrice * (1 - spacing * i);
            if (price <= level && price > level * 0.99) {
              shouldBuy = true;
              reason = `Grid ${i}`;
              break;
            }
          }
          break;
        case 'dca':
          dcaCounterRef.current++;
          if (dcaCounterRef.current >= settings.dcaInterval) {
            shouldBuy = true;
            reason = 'DCA';
            dcaCounterRef.current = 0;
          }
          break;
        case 'scalp':
          const sma5 = calculateSMA(history, 5);
          const sma15 = calculateSMA(history, 15);
          if (sma5 > sma15) {
            shouldBuy = true;
            reason = 'Scalp';
          }
          break;
      }

      if (shouldBuy) {
        executeTrade('buy', selectedPair, reason);
      }
    }
  }, [prices, selectedPair, positions, balance, settings, executeTrade]);

  // ==================== BOT CONTROL ====================
  const toggleBot = useCallback(() => {
    if (isRunning) {
      clearInterval(botIntervalRef.current);
      setIsRunning(false);
      addLog('Bot stopped', 'warning');
    } else {
      dcaCounterRef.current = 0;
      botIntervalRef.current = setInterval(runStrategy, 3000);
      setIsRunning(true);
      addLog(`Bot started: ${STRATEGIES[settings.strategy]?.name || settings.strategy}`, 'success');
    }
  }, [isRunning, runStrategy, settings.strategy, addLog]);



  // ==================== UPDATE INDICATORS ====================
  useEffect(() => {
    const history = priceHistoryRef.current[selectedPair];
    if (history && history.length > 20) {
      setIndicators({
        rsi: calculateRSI(history),
        macd: calculateMACD(history),
        bollinger: calculateBollingerBands(history),
        sma20: calculateSMA(history, 20),
        sma50: calculateSMA(history, 50)
      });
    }
  }, [selectedPair, prices]);

  // ==================== AI INTELLIGENCE UPDATE ====================
  useEffect(() => {
    if (!aiEnabled) return;
    const data = historicalData[selectedPair];
    const history = priceHistoryRef.current[selectedPair];
    if (data && data.length > 50) {
      // Update market regime
      const regime = detectMarketRegime(data, history);
      setMarketRegime(regime);

      // Update patterns
      const patterns = detectCandlestickPatterns(data);
      setDetectedPatterns(patterns);

      // Update support/resistance
      const levels = detectSupportResistance(data);
      setSupportResistance(levels);

      // Update sentiment
      const sent = calculateSentiment(data, history);
      setSentiment(sent);

      // Auto-switch strategy based on regime
      if (autoStrategy && regime.confidence > 0.6) {
        const suggestedStrategy = MARKET_REGIMES[regime.regime]?.strategy;
        if (suggestedStrategy && suggestedStrategy !== settings.strategy) {
          setSettings(s => ({ ...s, strategy: suggestedStrategy }));
          addLog(`AI switched to ${suggestedStrategy} (${regime.regime})`, 'info');
        }
      }
    }
  }, [historicalData, selectedPair, aiEnabled, autoStrategy, settings.strategy, addLog]);

  // ==================== PRO STRATEGIES UPDATE ====================
  useEffect(() => {
    if (!proStrategiesEnabled) return;
    const data = historicalData[selectedPair];
    const history = priceHistoryRef.current[selectedPair];
    const currentPrice = prices[selectedPair]?.price;

    if (data && data.length > 50 && history && history.length > 20 && currentPrice) {
      const newStats = { ...proStrategyStats };

      // Calculate Kelly Size
      const winRate = perfTrackerRef.current.getWinRate() / 100 || 0.5;
      const avgWin = 5; // Default or calculate from trades
      const avgLoss = 3;
      newStats.kellySize = calculateKellySize(winRate, avgWin, avgLoss) * proStrategySettings.kellyFraction * 2;

      // 200-Day MA Filter
      if (history.length >= 50) {
        const ma200Result = calculate200DayMAFilter(history);
        newStats.ma200Status = {
          aboveMA: ma200Result.aboveMA,
          distance: ma200Result.distance,
          ma200: ma200Result.ma200
        };
      }

      // Calculate R:R using support/resistance
      if (supportResistance.support.length > 0 && supportResistance.resistance.length > 0) {
        const nearestSupport = supportResistance.support[0]?.price || currentPrice * 0.95;
        const nearestResistance = supportResistance.resistance[0]?.price || currentPrice * 1.10;
        const stopLoss = currentPrice - (currentPrice - nearestSupport) * 0.5;
        const takeProfit = nearestResistance;
        const riskReward = calculateAsymmetricRisk(currentPrice, stopLoss, takeProfit, nearestSupport, nearestResistance);
        newStats.riskRewardRatio = riskReward.ratio;
      }

      // Turtle Trading Signals
      const turtle = calculateTurtleSignals(data);
      newStats.turtleSignal = turtle.signal;
      newStats.turtleHigh20 = turtle.high20;
      newStats.turtleATR = turtle.atr;
      newStats.turtleUnitSize = turtle.unitSize;
      newStats.turtleStop = turtle.stopLevel;

      // VCP Pattern
      const vcp = detectVCPPattern(data);
      newStats.vcpDetected = vcp.isVCP;
      newStats.vcpBreakout = vcp.breakoutLevel;
      newStats.vcpConfidence = vcp.confidence;

      // Fear & Greed
      const fg = calculateFearGreed(data, history);
      newStats.fearGreedScore = fg.score;
      newStats.fearGreedLabel = fg.label;
      newStats.fearGreedSignal = fg.signal;

      // Pyramiding level
      const pyramidPos = pyramidManagerRef.current.positions[selectedPair];
      newStats.pyramidLevel = pyramidPos ? pyramidPos.entries.length : 0;

      // Rules Check
      const position = positions[selectedPair];
      const currentLoss = position ? Math.max(0, (position.entry - currentPrice) / position.entry) : 0;
      newStats.rulesCheck = checkProfitRules({
        currentLoss,
        position: !!position,
        ma200Filter: newStats.ma200Status,
        riskReward: { ratio: newStats.riskRewardRatio },
        confidence: sentiment.score > 50 ? (sentiment.score / 100) : 0.5,
        fearGreed: { score: newStats.fearGreedScore },
        sentiment,
        winRate,
        avgWin,
        avgLoss
      });

      setProStrategyStats(newStats);
    }
  }, [historicalData, selectedPair, prices, proStrategiesEnabled, proStrategySettings, supportResistance, sentiment, positions]);

  // ==================== RL AGENT UPDATE ====================
  useEffect(() => {
    if (!aiEnabled || !isRunning) return;
    const history = priceHistoryRef.current[selectedPair];
    if (!history || history.length < 30) return;

    const currentPrice = prices[selectedPair]?.price;
    if (!currentPrice) return;

    // Build current state
    const rsi = calculateRSI(history);
    const priceChange = history.length > 5 ? (currentPrice - history[history.length - 5]) / history[history.length - 5] : 0;
    const currentState = {
      rsi: rsi,
      trend: priceChange,
      regime: marketRegime.regime,
      hasPosition: !!positions[selectedPair]
    };

    // If we had a previous state and action, calculate reward and update
    if (lastStateRef.current && lastActionRef.current !== null) {
      const prevPrice = lastStateRef.current.price || currentPrice;
      let reward = 0;

      // Calculate reward based on action and outcome
      if (positions[selectedPair]) {
        const positionPnL = (currentPrice - positions[selectedPair].entry) / positions[selectedPair].entry;
        reward = positionPnL * 100; // Scale reward
      } else if (lastActionRef.current === 2) { // Was a sell
        reward = 5; // Small reward for exiting
      }

      rlAgentRef.current.update(lastStateRef.current, lastActionRef.current, reward, currentState, false);
      replayBufferRef.current.add(lastStateRef.current, lastActionRef.current, reward, currentState, false);
    }

    // Store current state for next update
    lastStateRef.current = { ...currentState, price: currentPrice };

    // Update RL stats display
    setRlStats({
      epsilon: rlAgentRef.current.epsilon,
      totalReward: rlAgentRef.current.totalReward,
      trainingSteps: rlAgentRef.current.trainingSteps
    });
  }, [prices, selectedPair, aiEnabled, isRunning, marketRegime.regime, positions]);

  // ==================== UPDATE EQUITY CURVE ====================
  useEffect(() => {
    if (prices[selectedPair] && !loading) {
      const posValue = positions[selectedPair] ? positions[selectedPair].quantity * prices[selectedPair].price : 0;
      setEquityCurve(prev => [...prev.slice(-100), { time: new Date().toLocaleTimeString(), equity: balance + posValue }]);
    }
  }, [prices, balance, positions, selectedPair, loading]);

  // ==================== LOAD/SAVE STORAGE ====================
  useEffect(() => {
    const loadData = () => {
      try {
        const savedSettings = loadFromStorage(STORAGE_KEYS.settings, null);
        const savedTrades = loadFromStorage(STORAGE_KEYS.trades, []);
        const savedPortfolio = loadFromStorage(STORAGE_KEYS.portfolio, null);
        const savedRlAgent = loadFromStorage(STORAGE_KEYS.rlAgent, null);
        const savedEvolver = loadFromStorage(STORAGE_KEYS.evolver, null);
        const savedPerfTracker = loadFromStorage(STORAGE_KEYS.perfTracker, null);

        if (savedSettings) setSettings(prev => ({ ...prev, ...savedSettings }));
        if (savedTrades.length) setTrades(savedTrades);
        if (savedPortfolio) {
          setBalance(savedPortfolio.balance || 20);
          setPositions(savedPortfolio.positions || {});
          if (savedPortfolio.equityCurve) setEquityCurve(savedPortfolio.equityCurve);
        }

        // Load AI state
        if (savedRlAgent) {
          rlAgentRef.current.fromJSON(savedRlAgent);
          setRlStats({ epsilon: rlAgentRef.current.epsilon, totalReward: rlAgentRef.current.totalReward, trainingSteps: rlAgentRef.current.trainingSteps });
        }
        if (savedEvolver) {
          evolverRef.current.fromJSON(savedEvolver);
          setEvolverStats({ generation: evolverRef.current.generation, bestFitness: evolverRef.current.bestEver?.fitness || 0 });
        } else {
          evolverRef.current.initialize();
        }
        if (savedPerfTracker) perfTrackerRef.current.fromJSON(savedPerfTracker);

        // Load Pro Strategies state
        const savedPyramiding = loadFromStorage(STORAGE_KEYS.pyramiding, null);
        const savedCompound = loadFromStorage(STORAGE_KEYS.compound, null);
        const savedProSettings = loadFromStorage(STORAGE_KEYS.proStrategies, null);
        if (savedPyramiding) pyramidManagerRef.current.fromJSON(savedPyramiding);
        if (savedCompound) compoundOptimizerRef.current.fromJSON(savedCompound);
        if (savedProSettings) setProStrategySettings(prev => ({ ...prev, ...savedProSettings }));

        addLog('Session + AI + Pro state restored', 'success');
      } catch (e) {
        evolverRef.current.initialize();
        addLog('New session started', 'info');
      }
      setLoading(false);
    };
    loadData();
  }, [addLog]);

  useEffect(() => {
    if (!loading) {
      const saveData = () => {
        saveToStorage(STORAGE_KEYS.settings, settings);
        saveToStorage(STORAGE_KEYS.trades, trades.slice(-500));
        saveToStorage(STORAGE_KEYS.portfolio, { balance, positions, equityCurve: equityCurve.slice(-200) });
        saveToStorage(STORAGE_KEYS.rlAgent, rlAgentRef.current.toJSON());
        saveToStorage(STORAGE_KEYS.evolver, evolverRef.current.toJSON());
        saveToStorage(STORAGE_KEYS.perfTracker, perfTrackerRef.current.toJSON());
        // Save Pro Strategies state
        saveToStorage(STORAGE_KEYS.pyramiding, pyramidManagerRef.current.toJSON());
        saveToStorage(STORAGE_KEYS.compound, compoundOptimizerRef.current.toJSON());
        saveToStorage(STORAGE_KEYS.proStrategies, proStrategySettings);
      };
      const timeout = setTimeout(saveData, 3000);
      return () => clearTimeout(timeout);
    }
  }, [loading, settings, trades, balance, positions, equityCurve, proStrategySettings]);

  // ==================== CLEANUP ====================
  useEffect(() => {
    return () => {
      if (botIntervalRef.current) clearInterval(botIntervalRef.current);
      if (wsRef.current) wsRef.current.close();
    };
  }, []);

  // ==================== DERIVED VALUES ====================
  const currentPrice = prices[selectedPair]?.price || 0;
  const currentChange = prices[selectedPair]?.change24h || 0;
  const totalPnL = balance - initialBalance + (positions[selectedPair] ? positions[selectedPair].quantity * currentPrice - positions[selectedPair].cost : 0);
  const winTrades = trades.filter(t => t.pnl > 0).length;
  const loseTrades = trades.filter(t => t.pnl < 0).length;
  const winRate = trades.filter(t => t.pnl !== undefined).length > 0 ? (winTrades / trades.filter(t => t.pnl !== undefined).length * 100) : 0;
  const chartHistory = priceHistoryRef.current[selectedPair] || [];

  // ==================== LOADING STATE ====================
  if (loading) {
    return (
      <div className="min-h-screen bg-gradient-to-br from-slate-950 via-slate-900 to-slate-950 flex items-center justify-center">
        <div className="w-16 h-16 border-4 border-cyan-500 border-t-transparent rounded-full animate-spin"></div>
      </div>
    );
  }

  // ==================== RENDER ====================
  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-950 via-slate-900 to-slate-950 text-white">
      {/* Header */}
      <header className="border-b border-slate-800/50 bg-slate-900/80 backdrop-blur-xl sticky top-0 z-50">
        <div className="max-w-7xl mx-auto px-4 py-3 flex items-center justify-between">
          <div className="flex items-center gap-4">
            <div className="flex items-center gap-2">
              <div className="w-10 h-10 rounded-xl bg-gradient-to-br from-cyan-400 via-emerald-400 to-cyan-500 flex items-center justify-center font-black text-slate-900 text-lg shadow-lg shadow-cyan-500/25">K</div>
              <div>
                <div className="font-bold text-lg">KrakenBot Pro</div>
                <div className="text-[10px] text-slate-500 uppercase tracking-widest">Day Trading</div>
              </div>
            </div>
            <span className={`px-3 py-1 rounded-full text-xs font-semibold ${mode === 'paper' ? 'bg-amber-500/20 text-amber-400 border border-amber-500/30' : 'bg-emerald-500/20 text-emerald-400 border border-emerald-500/30'}`}>
              {mode === 'paper' ? 'ðŸ“ PAPER' : 'ðŸ’° LIVE'}
            </span>
            <span className={`px-2 py-1 rounded text-xs ${apiStatus === 'connected' ? 'bg-emerald-500/20 text-emerald-400' : apiStatus === 'connecting' ? 'bg-amber-500/20 text-amber-400 animate-pulse' : 'bg-slate-700 text-slate-400'}`}>
              API: {apiStatus}
            </span>
            {aiEnabled && (
              <span className={`px-2 py-1 rounded text-xs bg-purple-500/20 text-purple-400 border border-purple-500/30`}>
                ðŸ§  AI: {MARKET_REGIMES[marketRegime.regime]?.icon} {marketRegime.regime.replace('_', ' ')}
              </span>
            )}
          </div>

          <div className="flex items-center gap-3">
            <button
              onClick={() => setSettings(s => ({ ...s, soundEnabled: !s.soundEnabled }))}
              className={`p-2 rounded-lg transition ${settings.soundEnabled ? 'bg-cyan-500/20 text-cyan-400' : 'bg-slate-800 text-slate-500'}`}
            >
              {settings.soundEnabled ? 'ðŸ”Š' : 'ðŸ”‡'}
            </button>
            <div className="flex items-center gap-2 px-3 py-1.5 rounded-lg bg-slate-800/50">
              <div className={`w-2 h-2 rounded-full ${apiStatus === 'connected' ? 'bg-emerald-400 animate-pulse' : 'bg-slate-600'}`}></div>
              <span className="text-sm text-slate-400">{apiStatus === 'connected' ? 'Kraken Live' : 'Disconnected'}</span>
            </div>
            <button onClick={() => setShowSettings(!showSettings)} className="p-2 rounded-lg bg-slate-800/50 hover:bg-slate-700/50 transition">âš™ï¸</button>
          </div>
        </div>
      </header>

      <div className="max-w-7xl mx-auto p-4 space-y-4">
        {/* Settings Panel */}
        {showSettings && (
          <div className="bg-slate-800/40 backdrop-blur-xl rounded-2xl border border-slate-700/50 p-5 space-y-4">
            <div className="flex items-center justify-between">
              <h3 className="text-lg font-bold">âš™ï¸ Settings</h3>
              <button onClick={() => setShowSettings(false)} className="text-slate-400 hover:text-white">âœ•</button>
            </div>

            <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
              {/* Mode & Connection */}
              <div className="space-y-3">
                <div className="text-sm text-slate-400 font-medium">Mode & Exchange</div>
                <div className="flex gap-2">
                  <button onClick={() => { setMode('paper'); disconnectWebSocket(); }} className={`flex-1 py-2 rounded-xl font-medium transition ${mode === 'paper' ? 'bg-amber-500 text-slate-900' : 'bg-slate-700 hover:bg-slate-600'}`}>Paper</button>
                  <button onClick={() => setMode('live')} className={`flex-1 py-2 rounded-xl font-medium transition ${mode === 'live' ? 'bg-emerald-500 text-slate-900' : 'bg-slate-700 hover:bg-slate-600'}`}>Live</button>
                </div>

                {/* Exchange Selector */}
                <div className="flex gap-1">
                  {Object.entries(EXCHANGES).map(([key, ex]) => (
                    <button
                      key={key}
                      onClick={() => {
                        if (apiStatus === 'connected' && activeExchange !== key) {
                          connectToExchange(key);
                        } else {
                          setActiveExchange(key);
                        }
                      }}
                      className={`flex-1 py-1.5 rounded-lg text-xs font-medium transition flex items-center justify-center gap-1 ${
                        activeExchange === key
                          ? `bg-${ex.color}-500/30 text-${ex.color}-400 border border-${ex.color}-500/50`
                          : 'bg-slate-700/50 hover:bg-slate-600/50'
                      }`}
                    >
                      <span>{ex.icon}</span>
                      <span>{ex.name}</span>
                    </button>
                  ))}
                </div>

                <button
                  onClick={() => apiStatus === 'connected' ? disconnectWebSocket() : connectToExchange(activeExchange)}
                  disabled={apiStatus === 'connecting'}
                  className={`w-full py-2.5 rounded-xl font-semibold transition ${
                    apiStatus === 'connected'
                      ? 'bg-red-500/20 text-red-400 border border-red-500/30 hover:bg-red-500/30'
                      : apiStatus === 'connecting'
                      ? 'bg-slate-600 text-slate-400'
                      : 'bg-gradient-to-r from-cyan-500 to-emerald-500 text-white hover:from-cyan-600 hover:to-emerald-600'
                  }`}
                >
                  {apiStatus === 'connecting' ? 'â³ Connecting...' : apiStatus === 'connected' ? `â¹ Disconnect ${EXCHANGES[activeExchange]?.name}` : `â–¶ Connect to ${EXCHANGES[activeExchange]?.name}`}
                </button>
                {mode === 'live' && (
                  <div className="space-y-2 pt-2 border-t border-slate-700">
                    <input type="password" placeholder="API Key" value={settings.apiKey} onChange={e => setSettings(s => ({ ...s, apiKey: e.target.value }))} className="w-full bg-slate-900/50 border border-slate-600 rounded-xl p-2.5 text-sm" />
                    <input type="password" placeholder="API Secret" value={settings.apiSecret} onChange={e => setSettings(s => ({ ...s, apiSecret: e.target.value }))} className="w-full bg-slate-900/50 border border-slate-600 rounded-xl p-2.5 text-sm" />
                    <button
                      onClick={async () => {
                        if (!settings.apiKey || !settings.apiSecret) {
                          addLog('Enter API Key and Secret first', 'error');
                          return;
                        }
                        addLog('Testing API keys...', 'info');
                        try {
                          // Test with balance endpoint via CORS proxy
                          const testUrl = 'https://api.kraken.com/0/public/SystemStatus';
                          const response = await fetch(`https://corsproxy.io/?${encodeURIComponent(testUrl)}`);
                          const data = await response.json();
                          if (data.result?.status === 'online') {
                            addLog('âœ“ Kraken API is online! Keys saved.', 'success');
                            addLog('Note: Private API requires server-side auth', 'warning');
                          } else {
                            addLog('Kraken API status: ' + (data.result?.status || 'unknown'), 'warning');
                          }
                        } catch (e) {
                          addLog('API test failed: ' + e.message, 'error');
                        }
                      }}
                      className="w-full py-2 bg-amber-500/20 text-amber-400 border border-amber-500/30 rounded-xl text-sm hover:bg-amber-500/30 transition"
                    >
                      ðŸ”‘ Test API Connection
                    </button>
                    <div className="text-xs text-slate-500 text-center">
                      âš ï¸ Live trading requires server-side implementation for security
                    </div>
                  </div>
                )}

                {/* OpenRouter AI Section */}
                <div className="space-y-2 pt-2 border-t border-slate-700 mt-2">
                  <div className="text-xs text-purple-400 font-medium">ðŸ§  AI Analysis (OpenRouter)</div>
                  <input
                    type="password"
                    placeholder="OpenRouter API Key"
                    value={settings.openRouterKey}
                    onChange={e => setSettings(s => ({ ...s, openRouterKey: e.target.value }))}
                    className="w-full bg-slate-900/50 border border-purple-500/30 rounded-xl p-2.5 text-sm"
                  />
                  <select
                    value={settings.aiModel}
                    onChange={e => setSettings(s => ({ ...s, aiModel: e.target.value }))}
                    className="w-full bg-slate-900/50 border border-purple-500/30 rounded-xl p-2 text-sm"
                  >
                    <option value="anthropic/claude-3.5-sonnet">Claude 3.5 Sonnet (Recommended)</option>
                    <option value="anthropic/claude-3-haiku">Claude 3 Haiku (Fast)</option>
                    <option value="openai/gpt-4-turbo">GPT-4 Turbo</option>
                    <option value="openai/gpt-3.5-turbo">GPT-3.5 Turbo (Budget)</option>
                    <option value="google/gemini-pro">Gemini Pro</option>
                    <option value="meta-llama/llama-3-70b-instruct">Llama 3 70B</option>
                  </select>
                  <div className="text-xs text-slate-500 text-center">
                    Get key at <a href="https://openrouter.ai/keys" target="_blank" className="text-purple-400 hover:underline">openrouter.ai/keys</a>
                  </div>
                </div>
              </div>

              {/* Strategy */}
              <div className="space-y-3">
                <div className="text-sm text-slate-400 font-medium">Strategy</div>
                <select value={settings.strategy} onChange={e => setSettings(s => ({ ...s, strategy: e.target.value }))} className="w-full bg-slate-900/50 border border-slate-600 rounded-xl p-2.5">
                  {Object.entries(STRATEGIES).map(([key, { name, icon }]) => (
                    <option key={key} value={key}>{icon} {name}</option>
                  ))}
                </select>
                <div className="grid grid-cols-2 gap-2">
                  <div>
                    <label className="text-xs text-slate-500">Stop Loss %</label>
                    <input type="number" value={settings.stopLoss} onChange={e => setSettings(s => ({ ...s, stopLoss: +e.target.value }))} className="w-full bg-slate-900/50 border border-slate-600 rounded-lg p-2 text-sm" />
                  </div>
                  <div>
                    <label className="text-xs text-slate-500">Take Profit %</label>
                    <input type="number" value={settings.takeProfit} onChange={e => setSettings(s => ({ ...s, takeProfit: +e.target.value }))} className="w-full bg-slate-900/50 border border-slate-600 rounded-lg p-2 text-sm" />
                  </div>
                </div>
              </div>

              {/* Risk */}
              <div className="space-y-3">
                <div className="text-sm text-slate-400 font-medium">Risk Management</div>
                <div>
                  <label className="text-xs text-slate-500">Trade Size: {settings.tradeSize}%</label>
                  <input type="range" min="10" max="100" step="5" value={settings.tradeSize} onChange={e => setSettings(s => ({ ...s, tradeSize: +e.target.value }))} className="w-full" />
                </div>
                <label className="flex items-center gap-2 cursor-pointer">
                  <input type="checkbox" checked={settings.trailingStop} onChange={e => setSettings(s => ({ ...s, trailingStop: e.target.checked }))} className="rounded" />
                  <span className="text-sm">Trailing Stop ({settings.trailingPercent}%)</span>
                </label>
              </div>

              {/* Presets */}
              <div className="space-y-3">
                <div className="text-sm text-slate-400 font-medium">Quick Presets</div>
                <div className="space-y-1 max-h-32 overflow-y-auto">
                  {Object.entries(STRATEGY_PRESETS).map(([key, preset]) => (
                    <button
                      key={key}
                      onClick={() => {
                        setSettings(s => ({ ...s, strategy: preset.strategy, stopLoss: preset.stopLoss, takeProfit: preset.takeProfit, tradeSize: preset.tradeSize }));
                        addLog(`Applied preset: ${preset.name}`, 'success');
                      }}
                      className="w-full text-left px-2 py-1.5 rounded-lg bg-slate-700/50 hover:bg-slate-600/50 text-xs transition"
                    >
                      <div className="font-medium">{preset.name}</div>
                      <div className="text-slate-400">{preset.desc}</div>
                    </button>
                  ))}
                </div>
              </div>
            </div>
          </div>
        )}

        {/* Stats Row */}
        <div className="grid grid-cols-2 md:grid-cols-6 gap-3">
          {[
            { label: 'Balance', value: `$${balance.toFixed(2)}` },
            { label: 'P&L', value: `${totalPnL >= 0 ? '+' : ''}$${totalPnL.toFixed(2)}`, color: totalPnL >= 0 ? 'text-emerald-400' : 'text-red-400' },
            { label: 'Win Rate', value: `${winRate.toFixed(0)}%` },
            { label: 'W/L', value: <><span className="text-emerald-400">{winTrades}</span>/<span className="text-red-400">{loseTrades}</span></> },
            { label: 'RSI', value: indicators.rsi.toFixed(0), color: indicators.rsi < 30 ? 'text-emerald-400' : indicators.rsi > 70 ? 'text-red-400' : '' },
            { label: 'MACD', value: indicators.macd.histogram?.toFixed(4) || '0', color: indicators.macd.histogram > 0 ? 'text-emerald-400' : 'text-red-400' },
          ].map((s, i) => (
            <div key={i} className="bg-gradient-to-br from-slate-800/60 to-slate-800/30 backdrop-blur rounded-2xl border border-slate-700/50 p-3">
              <div className="text-xs text-slate-500 uppercase">{s.label}</div>
              <div className={`text-xl font-bold font-mono mt-1 ${s.color || ''}`}>{s.value}</div>
            </div>
          ))}
        </div>

        {/* Main Grid */}
        <div className="grid grid-cols-1 lg:grid-cols-4 gap-4">
          {/* Sidebar */}
          <div className="space-y-4">
            {/* Heatmap */}
            <div className="bg-slate-800/30 backdrop-blur rounded-2xl border border-slate-700/50 p-3">
              <div className="text-xs text-slate-500 uppercase mb-2">Heatmap</div>
              <div className="grid grid-cols-5 gap-1">
                {[...TRADING_PAIRS].slice(0, 15).sort((a, b) => (prices[b]?.change24h || 0) - (prices[a]?.change24h || 0)).map(pair => {
                  const change = prices[pair]?.change24h || 0;
                  const intensity = Math.min(Math.abs(change) * 15, 80) / 100;
                  return (
                    <button
                      key={pair}
                      onClick={() => setSelectedPair(pair)}
                      className={`p-1 rounded text-[9px] font-bold transition ${selectedPair === pair ? 'ring-2 ring-cyan-400' : ''}`}
                      style={{ background: change >= 0 ? `rgba(16,185,129,${intensity})` : `rgba(239,68,68,${intensity})` }}
                    >
                      {pair.split('/')[0].slice(0, 3)}
                    </button>
                  );
                })}
              </div>
            </div>

            {/* Markets List */}
            <div className="bg-slate-800/30 backdrop-blur rounded-2xl border border-slate-700/50 overflow-hidden">
              <div className="p-3 border-b border-slate-700/50 text-sm font-medium">Markets</div>
              <div className="h-40 overflow-y-auto">
                {TRADING_PAIRS.slice(0, 20).map(pair => (
                  <button
                    key={pair}
                    onClick={() => setSelectedPair(pair)}
                    className={`w-full px-3 py-1.5 flex justify-between hover:bg-slate-700/30 border-l-2 text-sm transition ${selectedPair === pair ? 'bg-cyan-500/10 border-cyan-400' : 'border-transparent'}`}
                  >
                    <span className="font-medium">{pair.split('/')[0]}</span>
                    <div className="text-right">
                      <div className="font-mono text-xs">${formatPrice(prices[pair]?.price, pair)}</div>
                      <div className={`text-[10px] ${(prices[pair]?.change24h || 0) >= 0 ? 'text-emerald-400' : 'text-red-400'}`}>
                        {formatPercent(prices[pair]?.change24h)}
                      </div>
                    </div>
                  </button>
                ))}
              </div>
            </div>

            {/* Order Book */}
            <div className="bg-slate-800/30 backdrop-blur rounded-2xl border border-slate-700/50 p-3">
              <div className="text-xs text-slate-500 uppercase mb-2">Order Book</div>
              <div className="space-y-0.5 text-[10px] font-mono">
                {orderBook.asks.slice().reverse().slice(0, 4).map((a, i) => (
                  <div key={i} className="flex justify-between text-red-400">
                    <span>{formatPrice(a.price, selectedPair)}</span>
                    <span>{a.amount.toFixed(2)}</span>
                  </div>
                ))}
                <div className="text-center font-bold text-sm py-1">${formatPrice(currentPrice, selectedPair)}</div>
                {orderBook.bids.slice(0, 4).map((b, i) => (
                  <div key={i} className="flex justify-between text-emerald-400">
                    <span>{formatPrice(b.price, selectedPair)}</span>
                    <span>{b.amount.toFixed(2)}</span>
                  </div>
                ))}
              </div>
            </div>
          </div>

          {/* Main Content */}
          <div className="lg:col-span-3 space-y-4">
            {/* Price Header */}
            <div className="bg-slate-800/30 backdrop-blur rounded-2xl border border-slate-700/50 p-4">
              <div className="flex items-center justify-between">
                <div className="flex items-center gap-4">
                  <div className="w-12 h-12 rounded-2xl bg-gradient-to-br from-cyan-500/20 to-emerald-500/20 border border-cyan-500/30 flex items-center justify-center text-lg font-bold">
                    {selectedPair.split('/')[0].slice(0, 2)}
                  </div>
                  <div>
                    <div className="text-xl font-bold">{selectedPair}</div>
                    <div className="text-sm text-slate-400">{apiStatus === 'connected' ? 'Kraken Live' : 'No Data'}</div>
                  </div>
                </div>
                <div className="text-right">
                  <div className="text-3xl font-bold font-mono">${formatPrice(currentPrice, selectedPair)}</div>
                  <div className={`text-lg font-semibold ${currentChange >= 0 ? 'text-emerald-400' : 'text-red-400'}`}>
                    {currentChange >= 0 ? 'â–²' : 'â–¼'} {Math.abs(currentChange).toFixed(2)}%
                  </div>
                </div>
              </div>
            </div>

            {/* Tab Navigation */}
            <div className="flex gap-2 flex-wrap">
              {['chart', 'backtest', 'simulate', 'optimizer', 'scanner', 'ai', 'evolution', 'pro', 'market', 'risk', 'trades', 'equity'].map(tab => (
                <button
                  key={tab}
                  onClick={() => setActiveTab(tab)}
                  className={`px-4 py-2 rounded-xl text-sm font-medium transition ${activeTab === tab ? 'bg-cyan-500 text-slate-900' : 'bg-slate-800/50 hover:bg-slate-700/50'} ${tab === 'ai' || tab === 'evolution' ? 'border border-purple-500/30' : ''} ${tab === 'pro' || tab === 'market' ? 'border border-amber-500/30' : ''} ${tab === 'risk' ? 'border border-red-500/30' : ''} ${tab === 'simulate' ? 'border border-cyan-500/30' : ''}`}
                >
                  {tab === 'ai' ? 'ðŸ§  AI' : tab === 'evolution' ? 'ðŸ§¬ Evolution' : tab === 'pro' ? 'ðŸ† Pro' : tab === 'market' ? 'ðŸ“Š Market' : tab === 'risk' ? 'ðŸ›¡ï¸ Risk' : tab === 'simulate' ? 'ðŸŽ² Simulate' : tab.charAt(0).toUpperCase() + tab.slice(1)}
                </button>
              ))}
            </div>

            {/* Tab Content */}
            <div className="bg-slate-800/30 backdrop-blur rounded-2xl border border-slate-700/50 p-4 min-h-[300px]">
              {/* Chart Tab */}
              {activeTab === 'chart' && (
                <div>
                  <div className="flex justify-between items-center mb-4">
                    <div className="flex items-center gap-3">
                      <span className="text-sm text-slate-400">Price Chart ({chartHistory.length} points)</span>
                      <div className="flex gap-1 bg-slate-800/50 rounded-lg p-1">
                        <button
                          onClick={() => setSettings(s => ({ ...s, chartType: 'line' }))}
                          className={`px-2 py-1 rounded text-xs transition ${settings.chartType !== 'candle' ? 'bg-cyan-500/30 text-cyan-400' : 'bg-slate-700/50 hover:bg-slate-600/50'}`}
                        >
                          Line
                        </button>
                        <button
                          onClick={() => setSettings(s => ({ ...s, chartType: 'candle' }))}
                          className={`px-2 py-1 rounded text-xs transition ${settings.chartType === 'candle' ? 'bg-cyan-500/30 text-cyan-400' : 'bg-slate-700/50 hover:bg-slate-600/50'}`}
                        >
                          Candles
                        </button>
                      </div>
                    </div>
                    <div className="flex gap-1">
                      {Object.keys(TIMEFRAMES).map(tf => (
                        <button
                          key={tf}
                          onClick={() => setTimeframe(tf)}
                          className={`px-2 py-1 rounded text-xs transition ${timeframe === tf ? 'bg-cyan-500/30 text-cyan-400' : 'bg-slate-700/50 hover:bg-slate-600/50'}`}
                        >
                          {tf}
                        </button>
                      ))}
                    </div>
                  </div>
                  <div className="h-56 relative">
                    {chartHistory.length > 1 ? (
                      <svg viewBox="0 0 400 180" className="w-full h-full">
                        <defs>
                          <linearGradient id="chartGradient" x1="0" y1="0" x2="0" y2="1">
                            <stop offset="0%" stopColor="rgb(6, 182, 212)" stopOpacity="0.3"/>
                            <stop offset="100%" stopColor="rgb(6, 182, 212)" stopOpacity="0"/>
                          </linearGradient>
                        </defs>
                        {(() => {
                          const data = chartHistory.slice(-100);
                          const min = Math.min(...data);
                          const max = Math.max(...data);
                          const range = max - min || 1;

                          if (settings.chartType === 'candle') {
                            // Generate OHLC candles from price data
                            const candleCount = Math.min(50, Math.floor(data.length / 2));
                            const candleWidth = 380 / candleCount;
                            const candles = [];

                            for (let i = 0; i < candleCount; i++) {
                              const startIdx = Math.floor(i * data.length / candleCount);
                              const endIdx = Math.floor((i + 1) * data.length / candleCount);
                              const slice = data.slice(startIdx, endIdx);
                              if (slice.length === 0) continue;

                              const open = slice[0];
                              const close = slice[slice.length - 1];
                              const high = Math.max(...slice);
                              const low = Math.min(...slice);
                              const bullish = close >= open;

                              const x = 10 + i * candleWidth;
                              const wickX = x + candleWidth / 2 - 0.5;
                              const bodyWidth = candleWidth * 0.7;
                              const bodyX = x + (candleWidth - bodyWidth) / 2;

                              const scaleY = (price) => 165 - ((price - min) / range) * 150;

                              candles.push(
                                <g key={i}>
                                  {/* Wick */}
                                  <line
                                    x1={wickX} y1={scaleY(high)}
                                    x2={wickX} y2={scaleY(low)}
                                    stroke={bullish ? '#10b981' : '#ef4444'}
                                    strokeWidth="1"
                                  />
                                  {/* Body */}
                                  <rect
                                    x={bodyX}
                                    y={scaleY(Math.max(open, close))}
                                    width={bodyWidth}
                                    height={Math.max(2, Math.abs(scaleY(open) - scaleY(close)))}
                                    fill={bullish ? '#10b981' : '#ef4444'}
                                    rx="1"
                                  />
                                </g>
                              );
                            }

                            return (
                              <>
                                {/* Candles */}
                                {candles}
                                {/* SMA line */}
                                {indicators.sma20 > 0 && (
                                  <line
                                    x1="10" y1={165 - ((indicators.sma20 - min) / range) * 150}
                                    x2="390" y2={165 - ((indicators.sma20 - min) / range) * 150}
                                    stroke="rgba(251, 191, 36, 0.6)" strokeWidth="1.5" strokeDasharray="4"
                                  />
                                )}
                                {/* Bollinger Bands */}
                                {indicators.bollinger.upper > 0 && (
                                  <>
                                    <line x1="10" y1={165 - ((indicators.bollinger.upper - min) / range) * 150} x2="390" y2={165 - ((indicators.bollinger.upper - min) / range) * 150} stroke="rgba(168, 85, 247, 0.4)" strokeDasharray="3"/>
                                    <line x1="10" y1={165 - ((indicators.bollinger.lower - min) / range) * 150} x2="390" y2={165 - ((indicators.bollinger.lower - min) / range) * 150} stroke="rgba(168, 85, 247, 0.4)" strokeDasharray="3"/>
                                  </>
                                )}
                                {/* Support/Resistance levels */}
                                {supportResistance.support.slice(0, 2).map((s, i) => (
                                  <line key={`s${i}`} x1="10" y1={165 - ((s.price - min) / range) * 150} x2="390" y2={165 - ((s.price - min) / range) * 150} stroke="rgba(16, 185, 129, 0.4)" strokeWidth="1" strokeDasharray="6,3"/>
                                ))}
                                {supportResistance.resistance.slice(0, 2).map((r, i) => (
                                  <line key={`r${i}`} x1="10" y1={165 - ((r.price - min) / range) * 150} x2="390" y2={165 - ((r.price - min) / range) * 150} stroke="rgba(239, 68, 68, 0.4)" strokeWidth="1" strokeDasharray="6,3"/>
                                ))}
                                {/* Price labels */}
                                <text x="392" y="15" fill="#94a3b8" fontSize="8">${formatPrice(max, selectedPair)}</text>
                                <text x="392" y="170" fill="#94a3b8" fontSize="8">${formatPrice(min, selectedPair)}</text>
                              </>
                            );
                          }

                          // Line chart (original)
                          const points = data.map((p, i) => {
                            const x = 10 + (i / (data.length - 1)) * 380;
                            const y = 165 - ((p - min) / range) * 150;
                            return `${x},${y}`;
                          }).join(' ');
                          return (
                            <>
                              <polygon points={`10,175 ${points} 390,175`} fill="url(#chartGradient)"/>
                              <polyline points={points} fill="none" stroke="rgb(6, 182, 212)" strokeWidth="2"/>
                              {/* SMA line */}
                              {indicators.sma20 > 0 && (
                                <line
                                  x1="10" y1={165 - ((indicators.sma20 - min) / range) * 150}
                                  x2="390" y2={165 - ((indicators.sma20 - min) / range) * 150}
                                  stroke="rgba(251, 191, 36, 0.5)" strokeDasharray="4"
                                />
                              )}
                              {/* Bollinger Bands */}
                              {indicators.bollinger.upper > 0 && (
                                <>
                                  <line x1="10" y1={165 - ((indicators.bollinger.upper - min) / range) * 150} x2="390" y2={165 - ((indicators.bollinger.upper - min) / range) * 150} stroke="rgba(168, 85, 247, 0.3)" strokeDasharray="2"/>
                                  <line x1="10" y1={165 - ((indicators.bollinger.lower - min) / range) * 150} x2="390" y2={165 - ((indicators.bollinger.lower - min) / range) * 150} stroke="rgba(168, 85, 247, 0.3)" strokeDasharray="2"/>
                                </>
                              )}
                              {/* Current price marker */}
                              <circle cx="390" cy={165 - ((data[data.length - 1] - min) / range) * 150} r="4" fill="rgb(6, 182, 212)"/>
                              {/* Price labels */}
                              <text x="392" y="15" fill="#94a3b8" fontSize="8">${formatPrice(max, selectedPair)}</text>
                              <text x="392" y="170" fill="#94a3b8" fontSize="8">${formatPrice(min, selectedPair)}</text>
                            </>
                          );
                        })()}
                      </svg>
                    ) : (
                      <div className="flex items-center justify-center h-full text-slate-500">Collecting price data...</div>
                    )}
                  </div>
                  {/* Indicators */}
                  <div className="grid grid-cols-4 gap-2 mt-4 text-xs">
                    <div className="bg-slate-900/50 rounded-lg p-2">
                      <div className="text-slate-500">RSI</div>
                      <div className={`font-bold ${indicators.rsi < 30 ? 'text-emerald-400' : indicators.rsi > 70 ? 'text-red-400' : ''}`}>
                        {indicators.rsi.toFixed(1)}
                      </div>
                    </div>
                    <div className="bg-slate-900/50 rounded-lg p-2">
                      <div className="text-slate-500">MACD</div>
                      <div className={`font-bold ${indicators.macd.histogram > 0 ? 'text-emerald-400' : 'text-red-400'}`}>
                        {indicators.macd.histogram?.toFixed(4) || '0'}
                      </div>
                    </div>
                    <div className="bg-slate-900/50 rounded-lg p-2">
                      <div className="text-slate-500">BB Upper</div>
                      <div className="font-bold">{formatPrice(indicators.bollinger.upper, selectedPair)}</div>
                    </div>
                    <div className="bg-slate-900/50 rounded-lg p-2">
                      <div className="text-slate-500">BB Lower</div>
                      <div className="font-bold">{formatPrice(indicators.bollinger.lower, selectedPair)}</div>
                    </div>
                  </div>
                </div>
              )}

              {/* Backtest Tab - WITH CUSTOM TIME PERIOD */}
              {activeTab === 'backtest' && (
                <div className="space-y-4">
                  <div className="flex flex-col md:flex-row items-start md:items-center justify-between gap-4">
                    <div>
                      <div className="font-semibold">ðŸ“Š Historical Backtest</div>
                      <div className="text-sm text-slate-400">Test your strategy with REAL Kraken data</div>
                    </div>
                  </div>

                  {/* TIME PERIOD CONFIGURATION */}
                  <div className="bg-slate-900/50 rounded-xl p-4 space-y-3">
                    <div className="text-sm font-medium text-cyan-400">â±ï¸ Backtest Time Period</div>

                    <div className="flex items-center gap-4">
                      <label className="flex items-center gap-2 cursor-pointer">
                        <input
                          type="radio"
                          checked={!backtestConfig.useCustomDate}
                          onChange={() => setBacktestConfig(c => ({ ...c, useCustomDate: false }))}
                          className="text-cyan-500"
                        />
                        <span className="text-sm">Hours ago</span>
                      </label>
                      <label className="flex items-center gap-2 cursor-pointer">
                        <input
                          type="radio"
                          checked={backtestConfig.useCustomDate}
                          onChange={() => setBacktestConfig(c => ({ ...c, useCustomDate: true }))}
                          className="text-cyan-500"
                        />
                        <span className="text-sm">Custom dates</span>
                      </label>
                    </div>

                    {!backtestConfig.useCustomDate ? (
                      <div className="flex items-center gap-4">
                        <div>
                          <label className="text-xs text-slate-500">Hours back</label>
                          <input
                            type="number"
                            value={backtestConfig.hoursBack}
                            onChange={e => setBacktestConfig(c => ({ ...c, hoursBack: parseInt(e.target.value) || 36 }))}
                            className="w-24 bg-slate-800 border border-slate-600 rounded-lg p-2 text-sm"
                            placeholder="36"
                          />
                        </div>
                        <div className="flex gap-2 flex-wrap">
                          {[12, 24, 36, 48, 72, 168, 720].map(h => (
                            <button
                              key={h}
                              onClick={() => setBacktestConfig(c => ({ ...c, hoursBack: h }))}
                              className={`px-2 py-1 rounded text-xs transition ${backtestConfig.hoursBack === h ? 'bg-cyan-500/30 text-cyan-400' : 'bg-slate-700 hover:bg-slate-600'}`}
                            >
                              {h < 24 ? `${h}h` : h === 168 ? '1w' : h === 720 ? '30d' : `${h / 24}d`}
                            </button>
                          ))}
                        </div>
                      </div>
                    ) : (
                      <div className="grid grid-cols-2 gap-4">
                        <div>
                          <label className="text-xs text-slate-500">Start Date/Time</label>
                          <input
                            type="datetime-local"
                            value={backtestConfig.customStartDate}
                            onChange={e => setBacktestConfig(c => ({ ...c, customStartDate: e.target.value }))}
                            className="w-full bg-slate-800 border border-slate-600 rounded-lg p-2 text-sm"
                          />
                        </div>
                        <div>
                          <label className="text-xs text-slate-500">End Date/Time (optional)</label>
                          <input
                            type="datetime-local"
                            value={backtestConfig.customEndDate}
                            onChange={e => setBacktestConfig(c => ({ ...c, customEndDate: e.target.value }))}
                            className="w-full bg-slate-800 border border-slate-600 rounded-lg p-2 text-sm"
                          />
                        </div>
                      </div>
                    )}

                    <div className="flex gap-2">
                      <button
                        onClick={() => fetchHistoricalData(selectedPair, timeframe)}
                        disabled={dataStatus === 'loading'}
                        className="px-4 py-2 bg-slate-700 rounded-xl text-sm hover:bg-slate-600 transition disabled:opacity-50"
                      >
                        {dataStatus === 'loading' ? 'â³ Loading...' : 'ðŸ“¥ Fetch Data'}
                      </button>
                      <button
                        onClick={runBacktest}
                        disabled={isBacktesting}
                        className="px-6 py-2 bg-gradient-to-r from-purple-500 to-pink-500 rounded-xl font-semibold disabled:opacity-50 transition hover:from-purple-600 hover:to-pink-600"
                      >
                        {isBacktesting ? `â³ ${backtestProgress}%` : 'â–¶ Run Backtest'}
                      </button>
                    </div>

                    <div className="text-xs text-slate-400">{dataStatus}</div>
                  </div>

                  {/* Progress Bar */}
                  {isBacktesting && (
                    <div className="h-2 bg-slate-700 rounded-full overflow-hidden">
                      <div className="h-full bg-gradient-to-r from-purple-500 to-pink-500 transition-all" style={{ width: `${backtestProgress}%` }}/>
                    </div>
                  )}

                  {/* Results */}
                  {backtestResults && (
                    <div className="space-y-4">
                      <div className="grid grid-cols-4 gap-2">
                        {[
                          { label: 'Return', value: `${backtestResults.totalReturn >= 0 ? '+' : ''}${backtestResults.totalReturn.toFixed(1)}%`, color: backtestResults.totalReturn >= 0 ? 'text-emerald-400' : 'text-red-400' },
                          { label: 'Win Rate', value: `${backtestResults.winRate.toFixed(0)}%` },
                          { label: 'Max DD', value: `-${backtestResults.maxDrawdown.toFixed(1)}%`, color: 'text-red-400' },
                          { label: 'Profit Factor', value: backtestResults.profitFactor === Infinity ? 'âˆž' : backtestResults.profitFactor.toFixed(2) },
                          { label: 'Trades', value: backtestResults.trades },
                          { label: 'W/L', value: `${backtestResults.wins}/${backtestResults.losses}` },
                          { label: 'Avg Win', value: `$${backtestResults.avgWin.toFixed(2)}`, color: 'text-emerald-400' },
                          { label: 'Avg Loss', value: `-$${backtestResults.avgLoss.toFixed(2)}`, color: 'text-red-400' },
                        ].map((s, i) => (
                          <div key={i} className="bg-slate-900/50 rounded-xl p-2">
                            <div className="text-[10px] text-slate-500">{s.label}</div>
                            <div className={`text-lg font-bold ${s.color || ''}`}>{s.value}</div>
                          </div>
                        ))}
                      </div>

                      <div className="text-xs text-slate-400">
                        Period: {backtestResults.period.start} â†’ {backtestResults.period.end} ({backtestResults.period.candles} candles)
                      </div>

                      {/* Equity Curve */}
                      {backtestResults.equityHistory?.length > 1 && (
                        <div className="h-32">
                          <svg viewBox="0 0 400 100" className="w-full h-full">
                            {(() => {
                              const data = backtestResults.equityHistory;
                              const values = data.map(d => d.equity);
                              const min = Math.min(...values);
                              const max = Math.max(...values);
                              const range = max - min || 1;
                              const points = data.map((d, i) => {
                                const x = (i / (data.length - 1)) * 400;
                                const y = 90 - ((d.equity - min) / range) * 80;
                                return `${x},${y}`;
                              }).join(' ');
                              const startY = 90 - ((initialBalance - min) / range) * 80;
                              return (
                                <>
                                  <line x1="0" y1={startY} x2="400" y2={startY} stroke="rgba(100,116,139,0.5)" strokeDasharray="4"/>
                                  <polyline points={points} fill="none" stroke="rgb(16, 185, 129)" strokeWidth="2"/>
                                </>
                              );
                            })()}
                          </svg>
                        </div>
                      )}

                      {/* Trade List */}
                      {backtestResults.tradeList?.length > 0 && (
                        <div className="text-xs">
                          <div className="text-slate-400 mb-1">Trade History:</div>
                          <div className="max-h-32 overflow-y-auto space-y-1">
                            {backtestResults.tradeList.slice(-15).map((t, i) => (
                              <div key={i} className={`flex justify-between ${t.type === 'sell' ? (t.pnl >= 0 ? 'text-emerald-400' : 'text-red-400') : 'text-slate-400'}`}>
                                <span>{t.type.toUpperCase()} @ ${formatPrice(t.price, selectedPair)} â€” {t.reason}</span>
                                <span>{t.pnl !== undefined ? `${t.pnl >= 0 ? '+' : ''}$${t.pnl.toFixed(2)} (${t.pnlPct?.toFixed(1)}%)` : ''}</span>
                              </div>
                            ))}
                          </div>
                        </div>
                      )}
                    </div>
                  )}
                </div>
              )}

              {/* Advanced Simulation Tab */}
              {activeTab === 'simulate' && (
                <div className="space-y-4">
                  <div className="flex items-center justify-between">
                    <div>
                      <div className="font-semibold">ðŸŽ² Advanced Simulation & Analysis</div>
                      <div className="text-sm text-slate-400">Monte Carlo, Walk-Forward, Statistical Testing</div>
                    </div>
                    <button
                      onClick={async () => {
                        if (trades.length < 10) {
                          addLog('Need at least 10 trades for simulation', 'warning');
                          return;
                        }
                        setIsSimulating(true);
                        addLog('Running Monte Carlo simulation...', 'info');

                        try {
                          // Monte Carlo
                          const mc = new MonteCarloSimulator(trades, simulationConfig.monteCarloIterations);
                          const mcResults = mc.runSimulation(balance);

                          // Statistical Tests
                          const statTester = new StatisticalTester(trades);
                          const statResults = statTester.runAllTests();

                          // Performance Analysis
                          const equityArr = equityCurve.map(e => e.value);
                          const perfAnalyzer = new PerformanceAnalyzer(trades, equityArr);
                          const perfReport = perfAnalyzer.generateFullReport();

                          // Market Simulator (realistic costs)
                          const marketSim = new MarketSimulator();
                          const costAnalysis = marketSim.backtestWithRealisticCosts(trades);

                          setSimulationResults({
                            monteCarlo: mcResults,
                            costAnalysis: costAnalysis.summary
                          });
                          setStatisticalTests(statResults);
                          setPerformanceReport(perfReport);

                          addLog(`Monte Carlo complete: ${mcResults.summary.profitablePct.toFixed(1)}% profitable scenarios`, 'success');
                          sendNotification('Simulation Complete', `${mcResults.iterations} iterations analyzed`, 'success');
                        } catch (err) {
                          addLog('Simulation error: ' + err.message, 'error');
                        }
                        setIsSimulating(false);
                      }}
                      disabled={isSimulating || trades.length < 10}
                      className={`px-4 py-2 rounded-xl text-sm font-medium ${isSimulating ? 'bg-slate-600 cursor-not-allowed' : 'bg-gradient-to-r from-cyan-500 to-purple-500 hover:from-cyan-600 hover:to-purple-600'}`}
                    >
                      {isSimulating ? 'â³ Running...' : 'â–¶ Run Full Analysis'}
                    </button>
                  </div>

                  {/* Simulation Config */}
                  <div className="bg-slate-900/50 rounded-xl p-4">
                    <div className="text-sm font-medium mb-3">âš™ï¸ Simulation Parameters</div>
                    <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                      <div>
                        <label className="text-xs text-slate-400">Monte Carlo Iterations</label>
                        <select
                          value={simulationConfig.monteCarloIterations}
                          onChange={e => setSimulationConfig(s => ({ ...s, monteCarloIterations: parseInt(e.target.value) }))}
                          className="w-full bg-slate-800 rounded px-2 py-1.5 text-sm mt-1"
                        >
                          <option value="500">500 (Fast)</option>
                          <option value="1000">1,000 (Standard)</option>
                          <option value="5000">5,000 (Thorough)</option>
                          <option value="10000">10,000 (Research)</option>
                        </select>
                      </div>
                      <div>
                        <label className="text-xs text-slate-400">Confidence Level</label>
                        <select
                          value={simulationConfig.confidenceLevel}
                          onChange={e => setSimulationConfig(s => ({ ...s, confidenceLevel: parseInt(e.target.value) }))}
                          className="w-full bg-slate-800 rounded px-2 py-1.5 text-sm mt-1"
                        >
                          <option value="90">90%</option>
                          <option value="95">95%</option>
                          <option value="99">99%</option>
                        </select>
                      </div>
                      <label className="flex items-center gap-2 cursor-pointer">
                        <input
                          type="checkbox"
                          checked={simulationConfig.includeSlippage}
                          onChange={e => setSimulationConfig(s => ({ ...s, includeSlippage: e.target.checked }))}
                          className="rounded"
                        />
                        <span className="text-sm">Include Slippage</span>
                      </label>
                      <label className="flex items-center gap-2 cursor-pointer">
                        <input
                          type="checkbox"
                          checked={simulationConfig.includeFees}
                          onChange={e => setSimulationConfig(s => ({ ...s, includeFees: e.target.checked }))}
                          className="rounded"
                        />
                        <span className="text-sm">Include Fees</span>
                      </label>
                    </div>
                  </div>

                  {/* Results Display */}
                  {simulationResults && (
                    <div className="space-y-4">
                      {/* Monte Carlo Results */}
                      <div className="bg-gradient-to-r from-cyan-500/10 to-purple-500/10 rounded-xl p-4 border border-cyan-500/30">
                        <div className="text-sm font-medium mb-3">ðŸŽ² Monte Carlo Simulation ({simulationResults.monteCarlo.iterations.toLocaleString()} iterations)</div>
                        <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                          <div className="bg-slate-900/50 rounded-lg p-3">
                            <div className="text-xs text-slate-500">Avg Return</div>
                            <div className={`text-xl font-bold ${simulationResults.monteCarlo.summary.avgReturn >= 0 ? 'text-emerald-400' : 'text-red-400'}`}>
                              {simulationResults.monteCarlo.summary.avgReturn >= 0 ? '+' : ''}{simulationResults.monteCarlo.summary.avgReturn.toFixed(2)}%
                            </div>
                          </div>
                          <div className="bg-slate-900/50 rounded-lg p-3">
                            <div className="text-xs text-slate-500">Profitable Scenarios</div>
                            <div className={`text-xl font-bold ${simulationResults.monteCarlo.summary.profitablePct >= 50 ? 'text-emerald-400' : 'text-red-400'}`}>
                              {simulationResults.monteCarlo.summary.profitablePct.toFixed(1)}%
                            </div>
                          </div>
                          <div className="bg-slate-900/50 rounded-lg p-3">
                            <div className="text-xs text-slate-500">Avg Sharpe</div>
                            <div className={`text-xl font-bold ${simulationResults.monteCarlo.summary.avgSharpe >= 1 ? 'text-emerald-400' : simulationResults.monteCarlo.summary.avgSharpe >= 0 ? 'text-amber-400' : 'text-red-400'}`}>
                              {simulationResults.monteCarlo.summary.avgSharpe.toFixed(2)}
                            </div>
                          </div>
                          <div className="bg-slate-900/50 rounded-lg p-3">
                            <div className="text-xs text-slate-500">Avg Max Drawdown</div>
                            <div className="text-xl font-bold text-red-400">
                              -{simulationResults.monteCarlo.summary.avgDrawdown.toFixed(1)}%
                            </div>
                          </div>
                        </div>

                        {/* Confidence Intervals */}
                        <div className="mt-4 grid grid-cols-3 gap-4">
                          <div className="bg-slate-800/50 rounded-lg p-3">
                            <div className="text-xs text-slate-500 mb-2">95% Return Range</div>
                            <div className="flex justify-between text-sm">
                              <span className="text-red-400">{simulationResults.monteCarlo.confidenceIntervals.return95.lower.toFixed(1)}%</span>
                              <span className="text-slate-400">â†’</span>
                              <span className="text-emerald-400">{simulationResults.monteCarlo.confidenceIntervals.return95.upper.toFixed(1)}%</span>
                            </div>
                          </div>
                          <div className="bg-slate-800/50 rounded-lg p-3">
                            <div className="text-xs text-slate-500 mb-2">95% Drawdown Range</div>
                            <div className="flex justify-between text-sm">
                              <span className="text-emerald-400">{simulationResults.monteCarlo.confidenceIntervals.drawdown95.lower.toFixed(1)}%</span>
                              <span className="text-slate-400">â†’</span>
                              <span className="text-red-400">{simulationResults.monteCarlo.confidenceIntervals.drawdown95.upper.toFixed(1)}%</span>
                            </div>
                          </div>
                          <div className="bg-slate-800/50 rounded-lg p-3">
                            <div className="text-xs text-slate-500 mb-2">Worst Case</div>
                            <div className="text-sm text-red-400">
                              Return: {simulationResults.monteCarlo.worstCase.worstReturn.toFixed(1)}% | DD: {simulationResults.monteCarlo.worstCase.maxDrawdown.toFixed(1)}%
                            </div>
                          </div>
                        </div>
                      </div>

                      {/* Statistical Significance */}
                      {statisticalTests && (
                        <div className="bg-gradient-to-r from-amber-500/10 to-orange-500/10 rounded-xl p-4 border border-amber-500/30">
                          <div className="text-sm font-medium mb-3">ðŸ“Š Statistical Significance Tests</div>
                          <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                            <div className="bg-slate-900/50 rounded-lg p-3">
                              <div className="text-xs text-slate-500">T-Test (p-value)</div>
                              <div className={`text-lg font-bold ${statisticalTests.tTest.isSignificant ? 'text-emerald-400' : 'text-red-400'}`}>
                                {statisticalTests.tTest.pValue.toFixed(4)}
                              </div>
                              <div className="text-xs mt-1">{statisticalTests.tTest.isSignificant ? 'âœ“ Significant' : 'âœ— Not significant'}</div>
                            </div>
                            <div className="bg-slate-900/50 rounded-lg p-3">
                              <div className="text-xs text-slate-500">Bootstrap CI</div>
                              <div className={`text-lg font-bold ${statisticalTests.bootstrapCI.excludesZero && statisticalTests.bootstrapCI.lower > 0 ? 'text-emerald-400' : 'text-amber-400'}`}>
                                [{statisticalTests.bootstrapCI.lower.toFixed(3)}, {statisticalTests.bootstrapCI.upper.toFixed(3)}]
                              </div>
                              <div className="text-xs mt-1">{statisticalTests.bootstrapCI.excludesZero ? 'Excludes zero' : 'Includes zero'}</div>
                            </div>
                            <div className="bg-slate-900/50 rounded-lg p-3">
                              <div className="text-xs text-slate-500">Profit Factor Test</div>
                              <div className={`text-lg font-bold ${statisticalTests.profitFactorTest.isSignificant ? 'text-emerald-400' : 'text-amber-400'}`}>
                                {statisticalTests.profitFactorTest.medianProfitFactor.toFixed(2)}
                              </div>
                              <div className="text-xs mt-1">{statisticalTests.profitFactorTest.isSignificant ? 'âœ“ PF > 1.0' : '? Inconclusive'}</div>
                            </div>
                            <div className="bg-slate-900/50 rounded-lg p-3">
                              <div className="text-xs text-slate-500">Overall Verdict</div>
                              <div className={`text-lg font-bold ${statisticalTests.isStatisticallySignificant.verdict === 'LIKELY PROFITABLE' ? 'text-emerald-400' : statisticalTests.isStatisticallySignificant.verdict === 'INCONCLUSIVE' ? 'text-amber-400' : 'text-red-400'}`}>
                                {statisticalTests.isStatisticallySignificant.verdict}
                              </div>
                              <div className="text-xs mt-1">Confidence: {statisticalTests.isStatisticallySignificant.confidence.toFixed(0)}%</div>
                            </div>
                          </div>
                        </div>
                      )}

                      {/* Performance Report */}
                      {performanceReport && (
                        <div className="bg-gradient-to-r from-emerald-500/10 to-teal-500/10 rounded-xl p-4 border border-emerald-500/30">
                          <div className="text-sm font-medium mb-3">ðŸ“ˆ Professional Performance Metrics</div>
                          <div className="grid grid-cols-2 md:grid-cols-4 gap-3 text-sm">
                            <div className="space-y-2">
                              <div className="text-slate-400 text-xs font-medium">RETURNS</div>
                              <div className="flex justify-between"><span className="text-slate-500">Total:</span><span>{performanceReport.returnMetrics.totalReturn}</span></div>
                              <div className="flex justify-between"><span className="text-slate-500">Annual:</span><span>{performanceReport.returnMetrics.annualizedReturn}</span></div>
                              <div className="flex justify-between"><span className="text-slate-500">Volatility:</span><span>{performanceReport.returnMetrics.annualizedVolatility}</span></div>
                            </div>
                            <div className="space-y-2">
                              <div className="text-slate-400 text-xs font-medium">RISK-ADJUSTED</div>
                              <div className="flex justify-between"><span className="text-slate-500">Sharpe:</span><span className={parseFloat(performanceReport.riskAdjusted.sharpeRatio) >= 1 ? 'text-emerald-400' : ''}>{performanceReport.riskAdjusted.sharpeRatio}</span></div>
                              <div className="flex justify-between"><span className="text-slate-500">Sortino:</span><span className={parseFloat(performanceReport.riskAdjusted.sortinoRatio) >= 1.5 ? 'text-emerald-400' : ''}>{performanceReport.riskAdjusted.sortinoRatio}</span></div>
                              <div className="flex justify-between"><span className="text-slate-500">Calmar:</span><span>{performanceReport.riskAdjusted.calmarRatio}</span></div>
                            </div>
                            <div className="space-y-2">
                              <div className="text-slate-400 text-xs font-medium">DRAWDOWN</div>
                              <div className="flex justify-between"><span className="text-slate-500">Max DD:</span><span className="text-red-400">{performanceReport.drawdown.maxDrawdown}</span></div>
                              <div className="flex justify-between"><span className="text-slate-500">Duration:</span><span>{performanceReport.drawdown.maxDrawdownDuration}</span></div>
                              <div className="flex justify-between"><span className="text-slate-500">Current:</span><span>{performanceReport.drawdown.currentDrawdown}</span></div>
                            </div>
                            <div className="space-y-2">
                              <div className="text-slate-400 text-xs font-medium">TAIL RISK</div>
                              <div className="flex justify-between"><span className="text-slate-500">VaR 95%:</span><span className="text-red-400">{performanceReport.tailRisk.var95}</span></div>
                              <div className="flex justify-between"><span className="text-slate-500">CVaR 95%:</span><span className="text-red-400">{performanceReport.tailRisk.cvar95}</span></div>
                              <div className="flex justify-between"><span className="text-slate-500">Max Loss:</span><span className="text-red-400">{performanceReport.tailRisk.maxLoss}</span></div>
                            </div>
                          </div>
                          <div className="mt-3 pt-3 border-t border-slate-700 grid grid-cols-4 gap-3 text-sm">
                            <div className="flex justify-between"><span className="text-slate-500">Trades:</span><span>{performanceReport.tradeStats.totalTrades}</span></div>
                            <div className="flex justify-between"><span className="text-slate-500">Win Rate:</span><span>{performanceReport.tradeStats.winRate}</span></div>
                            <div className="flex justify-between"><span className="text-slate-500">Profit Factor:</span><span className={parseFloat(performanceReport.tradeStats.profitFactor) >= 1.5 ? 'text-emerald-400' : ''}>{performanceReport.tradeStats.profitFactor}</span></div>
                            <div className="flex justify-between"><span className="text-slate-500">Expectancy:</span><span>{performanceReport.tradeStats.expectancy}</span></div>
                          </div>
                        </div>
                      )}

                      {/* Cost Analysis */}
                      {simulationResults.costAnalysis && (
                        <div className="bg-slate-800/50 rounded-xl p-4">
                          <div className="text-sm font-medium mb-2">ðŸ’° Realistic Cost Impact</div>
                          <div className="grid grid-cols-4 gap-4 text-sm">
                            <div>
                              <div className="text-slate-500 text-xs">Gross P&L</div>
                              <div className={simulationResults.costAnalysis.grossPnL >= 0 ? 'text-emerald-400' : 'text-red-400'}>
                                ${simulationResults.costAnalysis.grossPnL.toFixed(2)}
                              </div>
                            </div>
                            <div>
                              <div className="text-slate-500 text-xs">Total Costs</div>
                              <div className="text-red-400">-${simulationResults.costAnalysis.totalCosts.toFixed(2)}</div>
                            </div>
                            <div>
                              <div className="text-slate-500 text-xs">Net P&L</div>
                              <div className={simulationResults.costAnalysis.netPnL >= 0 ? 'text-emerald-400' : 'text-red-400'}>
                                ${simulationResults.costAnalysis.netPnL.toFixed(2)}
                              </div>
                            </div>
                            <div>
                              <div className="text-slate-500 text-xs">Cost Impact</div>
                              <div className="text-amber-400">{simulationResults.costAnalysis.costImpactPercent.toFixed(1)}%</div>
                            </div>
                          </div>
                        </div>
                      )}
                    </div>
                  )}

                  {/* No trades warning */}
                  {trades.length < 10 && (
                    <div className="bg-amber-500/10 border border-amber-500/30 rounded-xl p-4 text-center">
                      <div className="text-amber-400 font-medium">âš ï¸ Need More Data</div>
                      <div className="text-sm text-slate-400 mt-1">Run some trades first (minimum 10) to enable simulation analysis</div>
                      <div className="text-xs text-slate-500 mt-2">Current trades: {trades.length}</div>
                    </div>
                  )}
                </div>
              )}

              {/* Optimizer Tab */}
              {activeTab === 'optimizer' && (
                <div className="space-y-4">
                  <div className="flex items-center justify-between">
                    <div>
                      <div className="font-semibold">ðŸ¤– AI Parameter Optimizer</div>
                      <div className="text-sm text-slate-400">Tests SL/TP combinations on real data</div>
                    </div>
                    <button
                      onClick={runOptimizer}
                      disabled={isOptimizing}
                      className="px-6 py-2 bg-gradient-to-r from-violet-500 to-fuchsia-500 rounded-xl font-semibold disabled:opacity-50 transition hover:from-violet-600 hover:to-fuchsia-600"
                    >
                      {isOptimizing ? 'â³ Optimizing...' : 'â–¶ Run Optimizer'}
                    </button>
                  </div>

                  {optimizerResults && (
                    <div className="space-y-2">
                      {optimizerResults.map((r, i) => (
                        <div key={i} className={`flex items-center justify-between p-3 rounded-xl ${i === 0 ? 'bg-violet-500/20 border border-violet-500/30' : 'bg-slate-900/50'}`}>
                          <div className="flex items-center gap-4">
                            <span className="text-cyan-400 font-bold">#{i + 1}</span>
                            <span>SL: {r.stopLoss}%</span>
                            <span>TP: {r.takeProfit}%</span>
                          </div>
                          <div className="flex items-center gap-4 text-sm">
                            <span className={parseFloat(r.return) >= 0 ? 'text-emerald-400' : 'text-red-400'}>{r.return}%</span>
                            <span>WR: {r.winRate}%</span>
                            <button
                              onClick={() => {
                                setSettings(s => ({ ...s, stopLoss: r.stopLoss, takeProfit: r.takeProfit }));
                                addLog(`Applied: SL ${r.stopLoss}% / TP ${r.takeProfit}%`, 'success');
                              }}
                              className="px-3 py-1 bg-cyan-500/20 text-cyan-400 rounded-lg text-xs hover:bg-cyan-500/30 transition"
                            >
                              Apply
                            </button>
                          </div>
                        </div>
                      ))}
                    </div>
                  )}
                </div>
              )}

              {/* Scanner Tab */}
              {activeTab === 'scanner' && (
                <div className="space-y-4">
                  <div className="flex items-center justify-between">
                    <div>
                      <div className="font-semibold">ðŸ” Multi-Pair Scanner</div>
                      <div className="text-sm text-slate-400">Scans all pairs for trading signals</div>
                    </div>
                    <button
                      onClick={runScanner}
                      disabled={isScanning}
                      className="px-6 py-2 bg-gradient-to-r from-purple-500 to-pink-500 rounded-xl font-semibold disabled:opacity-50 transition"
                    >
                      {isScanning ? 'â³ Scanning...' : 'ðŸ” Scan Now'}
                    </button>
                  </div>

                  {scanResults.length > 0 && (
                    <div className="space-y-2">
                      {scanResults.map((r, i) => (
                        <div key={i} className="flex items-center justify-between p-3 bg-slate-900/50 rounded-xl">
                          <div className="flex items-center gap-3">
                            <button onClick={() => setSelectedPair(r.pair)} className="font-bold text-cyan-400 hover:underline">{r.pair}</button>
                            <span className={`px-2 py-0.5 rounded text-xs font-bold ${r.signal.includes('BUY') ? 'bg-emerald-500/20 text-emerald-400' : 'bg-red-500/20 text-red-400'}`}>
                              {r.signal}
                            </span>
                          </div>
                          <div className="flex items-center gap-4 text-sm">
                            <span>RSI: {r.rsi}</span>
                            <span className={parseFloat(r.change) >= 0 ? 'text-emerald-400' : 'text-red-400'}>{r.change}%</span>
                          </div>
                        </div>
                      ))}
                    </div>
                  )}

                  {scanResults.length === 0 && !isScanning && (
                    <div className="text-center text-slate-500 py-8">Click "Scan Now" to find trading signals</div>
                  )}
                </div>
              )}

              {/* AI Intelligence Tab */}
              {activeTab === 'ai' && (
                <div className="space-y-4">
                  <div className="flex items-center justify-between">
                    <div>
                      <div className="font-semibold">ðŸ§  AI Intelligence Center</div>
                      <div className="text-sm text-slate-400">Real-time market analysis & pattern detection</div>
                    </div>
                    <div className="flex items-center gap-3">
                      <label className="flex items-center gap-2 cursor-pointer">
                        <input type="checkbox" checked={aiEnabled} onChange={e => setAiEnabled(e.target.checked)} className="rounded" />
                        <span className="text-sm">AI Enabled</span>
                      </label>
                      <label className="flex items-center gap-2 cursor-pointer">
                        <input type="checkbox" checked={autoStrategy} onChange={e => setAutoStrategy(e.target.checked)} className="rounded" />
                        <span className="text-sm">Auto-Switch Strategy</span>
                      </label>
                    </div>
                  </div>

                  {/* Market Regime */}
                  <div className="bg-slate-900/50 rounded-xl p-4">
                    <div className="text-sm text-slate-400 mb-2">Market Regime</div>
                    <div className="flex items-center justify-between">
                      <div className="flex items-center gap-3">
                        <span className="text-3xl">{MARKET_REGIMES[marketRegime.regime]?.icon || 'â“'}</span>
                        <div>
                          <div className={`text-xl font-bold text-${MARKET_REGIMES[marketRegime.regime]?.color || 'slate'}-400`}>
                            {MARKET_REGIMES[marketRegime.regime]?.name || marketRegime.regime}
                          </div>
                          <div className="text-xs text-slate-500">Confidence: {(marketRegime.confidence * 100).toFixed(0)}%</div>
                        </div>
                      </div>
                      <div className="text-right text-sm">
                        <div>ADX: <span className="font-mono">{marketRegime.adx?.toFixed(1)}</span></div>
                        <div>ATR: <span className="font-mono">{marketRegime.atr?.toFixed(4)}</span></div>
                        <div>Suggested: <span className="text-cyan-400">{MARKET_REGIMES[marketRegime.regime]?.strategy}</span></div>
                      </div>
                    </div>
                  </div>

                  {/* Sentiment Gauge */}
                  <div className="bg-slate-900/50 rounded-xl p-4">
                    <div className="text-sm text-slate-400 mb-2">Market Sentiment</div>
                    <div className="flex items-center gap-4">
                      <div className="flex-1">
                        <div className="h-4 bg-slate-700 rounded-full overflow-hidden">
                          <div
                            className={`h-full transition-all ${sentiment.score > 0 ? 'bg-emerald-500' : 'bg-red-500'}`}
                            style={{ width: `${Math.abs(sentiment.score)}%`, marginLeft: sentiment.score < 0 ? `${50 + sentiment.score / 2}%` : '50%' }}
                          />
                        </div>
                        <div className="flex justify-between text-xs text-slate-500 mt-1">
                          <span>Bearish</span>
                          <span>Neutral</span>
                          <span>Bullish</span>
                        </div>
                      </div>
                      <div className="text-right">
                        <div className={`text-2xl font-bold ${sentiment.score > 15 ? 'text-emerald-400' : sentiment.score < -15 ? 'text-red-400' : 'text-slate-400'}`}>
                          {sentiment.score > 0 ? '+' : ''}{sentiment.score.toFixed(0)}
                        </div>
                        <div className="text-xs text-slate-400">{sentiment.label}</div>
                      </div>
                    </div>
                    <div className="flex gap-2 mt-3">
                      {sentiment.factors.map((f, i) => (
                        <div key={i} className={`text-xs px-2 py-1 rounded ${f.positive ? 'bg-emerald-500/20 text-emerald-400' : 'bg-red-500/20 text-red-400'}`}>
                          {f.name}: {f.value}
                        </div>
                      ))}
                    </div>
                  </div>

                  {/* Detected Patterns */}
                  <div className="bg-slate-900/50 rounded-xl p-4">
                    <div className="text-sm text-slate-400 mb-2">Detected Patterns</div>
                    {detectedPatterns.length > 0 ? (
                      <div className="space-y-2">
                        {detectedPatterns.map((p, i) => (
                          <div key={i} className={`flex items-center justify-between p-2 rounded-lg ${p.type === 'bullish' ? 'bg-emerald-500/10 border border-emerald-500/30' : p.type === 'bearish' ? 'bg-red-500/10 border border-red-500/30' : 'bg-slate-700/50'}`}>
                            <div>
                              <span className="font-medium">{p.name}</span>
                              <span className="text-xs text-slate-400 ml-2">{p.description}</span>
                            </div>
                            <div className="flex items-center gap-2">
                              <span className={`text-xs px-2 py-0.5 rounded ${p.type === 'bullish' ? 'bg-emerald-500/20 text-emerald-400' : p.type === 'bearish' ? 'bg-red-500/20 text-red-400' : 'bg-slate-600 text-slate-300'}`}>
                                {p.type.toUpperCase()}
                              </span>
                              <span className="text-xs text-slate-400">{(p.confidence * 100).toFixed(0)}%</span>
                            </div>
                          </div>
                        ))}
                      </div>
                    ) : (
                      <div className="text-center text-slate-500 py-4">No patterns detected - fetch historical data first</div>
                    )}
                  </div>

                  {/* Support/Resistance */}
                  <div className="grid grid-cols-2 gap-4">
                    <div className="bg-slate-900/50 rounded-xl p-3">
                      <div className="text-xs text-emerald-400 mb-2">Support Levels</div>
                      {supportResistance.support.length > 0 ? supportResistance.support.map((l, i) => (
                        <div key={i} className="flex justify-between text-sm">
                          <span className="text-slate-400">S{i + 1}</span>
                          <span className="font-mono text-emerald-400">${formatPrice(l.price, selectedPair)}</span>
                        </div>
                      )) : <div className="text-xs text-slate-500">No levels detected</div>}
                    </div>
                    <div className="bg-slate-900/50 rounded-xl p-3">
                      <div className="text-xs text-red-400 mb-2">Resistance Levels</div>
                      {supportResistance.resistance.length > 0 ? supportResistance.resistance.map((l, i) => (
                        <div key={i} className="flex justify-between text-sm">
                          <span className="text-slate-400">R{i + 1}</span>
                          <span className="font-mono text-red-400">${formatPrice(l.price, selectedPair)}</span>
                        </div>
                      )) : <div className="text-xs text-slate-500">No levels detected</div>}
                    </div>
                  </div>

                  {/* OpenRouter AI Analysis */}
                  <div className="bg-gradient-to-br from-purple-900/30 to-violet-900/30 rounded-xl p-4 border border-purple-500/30">
                    <div className="flex items-center justify-between mb-3">
                      <div>
                        <div className="text-sm font-semibold text-purple-300">ðŸ¤– OpenRouter AI Analysis</div>
                        <div className="text-xs text-slate-400">Powered by {settings.aiModel?.split('/')[1] || 'Claude'}</div>
                      </div>
                      <div className="flex gap-2">
                        <button
                          onClick={fetchNewsSentiment}
                          disabled={isAiAnalyzing}
                          className="px-3 py-1.5 bg-indigo-500/20 text-indigo-400 border border-indigo-500/30 rounded-lg text-xs hover:bg-indigo-500/30 transition disabled:opacity-50"
                        >
                          ðŸ“° News
                        </button>
                        <button
                          onClick={runAiStrategyOptimizer}
                          disabled={isAiAnalyzing || trades.length < 5}
                          className="px-3 py-1.5 bg-violet-500/20 text-violet-400 border border-violet-500/30 rounded-lg text-xs hover:bg-violet-500/30 transition disabled:opacity-50"
                        >
                          ðŸ’¡ Improve Strategy
                        </button>
                        <button
                          onClick={runAiAnalysis}
                          disabled={isAiAnalyzing || !settings.openRouterKey}
                          className={`px-4 py-1.5 rounded-lg text-xs font-semibold transition ${
                            isAiAnalyzing ? 'bg-purple-500/30 text-purple-300' :
                            settings.openRouterKey ? 'bg-gradient-to-r from-purple-500 to-pink-500 text-white hover:from-purple-600 hover:to-pink-600' :
                            'bg-slate-700 text-slate-400'
                          }`}
                        >
                          {isAiAnalyzing ? 'â³ Analyzing...' : 'ðŸ§  Run AI Analysis'}
                        </button>
                      </div>
                    </div>

                    {!settings.openRouterKey && (
                      <div className="text-xs text-amber-400 bg-amber-500/10 border border-amber-500/30 rounded-lg p-2 mb-3">
                        âš ï¸ Enter your OpenRouter API key in Settings above to enable AI analysis
                      </div>
                    )}

                    {aiAnalysis && (
                      <div className="space-y-3">
                        {/* Signal Display */}
                        <div className={`flex items-center justify-between p-3 rounded-lg ${
                          aiAnalysis.signal === 'BUY' ? 'bg-emerald-500/20 border border-emerald-500/30' :
                          aiAnalysis.signal === 'SELL' ? 'bg-red-500/20 border border-red-500/30' :
                          'bg-slate-700/50 border border-slate-600/30'
                        }`}>
                          <div className="flex items-center gap-3">
                            <span className="text-3xl">{aiAnalysis.signal === 'BUY' ? 'ðŸŸ¢' : aiAnalysis.signal === 'SELL' ? 'ðŸ”´' : 'âšª'}</span>
                            <div>
                              <div className="text-xl font-bold">{aiAnalysis.signal}</div>
                              <div className="text-xs text-slate-400">Confidence: {aiAnalysis.confidence}%</div>
                            </div>
                          </div>
                          <div className="text-right text-sm">
                            <div>Risk/Reward: <span className="text-cyan-400">{aiAnalysis.risk_reward?.toFixed(1) || 'N/A'}</span></div>
                            <div>Timeframe: <span className="text-purple-400">{aiAnalysis.timeframe || 'short'}</span></div>
                          </div>
                        </div>

                        {/* Key Levels */}
                        {aiAnalysis.key_levels && (
                          <div className="grid grid-cols-3 gap-2">
                            <div className="bg-slate-800/50 rounded-lg p-2 text-center">
                              <div className="text-xs text-slate-400">Entry</div>
                              <div className="font-mono text-sm">${aiAnalysis.entry_price?.toFixed(2) || 'Market'}</div>
                            </div>
                            <div className="bg-red-500/10 rounded-lg p-2 text-center">
                              <div className="text-xs text-red-400">Stop Loss</div>
                              <div className="font-mono text-sm text-red-400">${aiAnalysis.stop_loss?.toFixed(2) || 'N/A'}</div>
                            </div>
                            <div className="bg-emerald-500/10 rounded-lg p-2 text-center">
                              <div className="text-xs text-emerald-400">Take Profit</div>
                              <div className="font-mono text-sm text-emerald-400">${aiAnalysis.take_profit?.toFixed(2) || 'N/A'}</div>
                            </div>
                          </div>
                        )}

                        {/* Reasoning */}
                        {aiAnalysis.reasoning && (
                          <div className="bg-slate-800/30 rounded-lg p-3">
                            <div className="text-xs text-slate-400 mb-1">AI Reasoning:</div>
                            <div className="text-sm">{aiAnalysis.reasoning}</div>
                          </div>
                        )}

                        {/* Warnings */}
                        {aiAnalysis.warnings && aiAnalysis.warnings.length > 0 && (
                          <div className="bg-amber-500/10 border border-amber-500/30 rounded-lg p-2">
                            <div className="text-xs text-amber-400">âš ï¸ Warnings:</div>
                            <ul className="text-xs text-amber-300 mt-1 space-y-1">
                              {aiAnalysis.warnings.map((w, i) => <li key={i}>â€¢ {w}</li>)}
                            </ul>
                          </div>
                        )}
                      </div>
                    )}

                    {/* News Sentiment */}
                    {newsSentiment.headlines.length > 0 && (
                      <div className="mt-3 pt-3 border-t border-purple-500/20">
                        <div className="flex items-center justify-between mb-2">
                          <div className="text-xs text-slate-400">ðŸ“° Latest News ({newsSentiment.headlines.length})</div>
                          {newsSentiment.aiAnalysis && (
                            <span className={`text-xs px-2 py-0.5 rounded ${
                              newsSentiment.aiAnalysis.trading_bias === 'bullish' ? 'bg-emerald-500/20 text-emerald-400' :
                              newsSentiment.aiAnalysis.trading_bias === 'bearish' ? 'bg-red-500/20 text-red-400' :
                              'bg-slate-600/50 text-slate-400'
                            }`}>
                              {newsSentiment.aiAnalysis.trading_bias?.toUpperCase()}
                            </span>
                          )}
                        </div>
                        <div className="space-y-1 max-h-32 overflow-y-auto">
                          {newsSentiment.headlines.slice(0, 5).map((h, i) => (
                            <a key={i} href={h.url} target="_blank" rel="noopener noreferrer" className="block text-xs text-slate-300 hover:text-cyan-400 truncate">
                              â€¢ {h.title}
                            </a>
                          ))}
                        </div>
                      </div>
                    )}

                    {/* AI History */}
                    {aiHistory.length > 0 && (
                      <div className="mt-3 pt-3 border-t border-purple-500/20">
                        <div className="text-xs text-slate-400 mb-2">ðŸ“œ Recent AI Signals</div>
                        <div className="space-y-1 max-h-24 overflow-y-auto">
                          {aiHistory.slice(0, 5).map((h, i) => (
                            <div key={i} className="flex items-center justify-between text-xs">
                              <span className="text-slate-500">{new Date(h.timestamp).toLocaleTimeString()}</span>
                              <span>{h.pair}</span>
                              <span className={h.analysis.signal === 'BUY' ? 'text-emerald-400' : h.analysis.signal === 'SELL' ? 'text-red-400' : 'text-slate-400'}>
                                {h.analysis.signal} ({h.analysis.confidence}%)
                              </span>
                            </div>
                          ))}
                        </div>
                      </div>
                    )}
                  </div>

                  {/* RL Agent Stats */}
                  <div className="bg-slate-900/50 rounded-xl p-4">
                    <div className="text-sm text-slate-400 mb-2">ðŸ¤– Reinforcement Learning Agent</div>
                    <div className="grid grid-cols-3 gap-4 text-center">
                      <div>
                        <div className="text-2xl font-bold text-purple-400">{rlStats.trainingSteps}</div>
                        <div className="text-xs text-slate-500">Training Steps</div>
                      </div>
                      <div>
                        <div className="text-2xl font-bold text-cyan-400">{(rlStats.epsilon * 100).toFixed(0)}%</div>
                        <div className="text-xs text-slate-500">Exploration Rate</div>
                      </div>
                      <div>
                        <div className={`text-2xl font-bold ${rlStats.totalReward >= 0 ? 'text-emerald-400' : 'text-red-400'}`}>
                          {rlStats.totalReward.toFixed(1)}
                        </div>
                        <div className="text-xs text-slate-500">Total Reward</div>
                      </div>
                    </div>
                  </div>
                </div>
              )}

              {/* Evolution Tab */}
              {activeTab === 'evolution' && (
                <div className="space-y-4">
                  <div className="flex items-center justify-between">
                    <div>
                      <div className="font-semibold">ðŸ§¬ Strategy Evolution</div>
                      <div className="text-sm text-slate-400">Genetic algorithm optimizes your strategy parameters</div>
                    </div>
                    <button
                      onClick={async () => {
                        setIsEvolving(true);
                        addLog('Running evolution cycle...', 'info');

                        // Simple fitness evaluation using backtest-like simulation
                        const data = historicalData[selectedPair];
                        if (!data || data.length < 50) {
                          addLog('Need historical data - fetch it first', 'error');
                          setIsEvolving(false);
                          return;
                        }

                        const closes = data.map(c => c.close);
                        const fitnessResults = evolverRef.current.population.map(individual => {
                          let bal = 20, pos = null, wins = 0;
                          for (let i = 50; i < closes.length; i++) {
                            const rsi = calculateRSI(closes.slice(0, i + 1));
                            if (!pos && rsi < individual.rsiOversold) {
                              pos = { entry: closes[i], qty: (bal * individual.tradeSize / 100) / closes[i] };
                              bal -= pos.qty * closes[i];
                            }
                            if (pos) {
                              const pnl = ((closes[i] - pos.entry) / pos.entry) * 100;
                              if (pnl <= -individual.stopLoss || pnl >= individual.takeProfit || rsi > individual.rsiOverbought) {
                                bal += pos.qty * closes[i];
                                if (pnl > 0) wins++;
                                pos = null;
                              }
                            }
                          }
                          if (pos) bal += pos.qty * closes[closes.length - 1];
                          return ((bal - 20) / 20) * 100;
                        });

                        const best = evolverRef.current.evolve(fitnessResults);
                        setEvolverStats({ generation: evolverRef.current.generation, bestFitness: best.fitness });
                        addLog(`Generation ${evolverRef.current.generation}: Best fitness ${best.fitness.toFixed(2)}%`, 'success');
                        setIsEvolving(false);
                      }}
                      disabled={isEvolving}
                      className="px-6 py-2 bg-gradient-to-r from-purple-500 to-pink-500 rounded-xl font-semibold disabled:opacity-50 transition"
                    >
                      {isEvolving ? 'â³ Evolving...' : 'ðŸ§¬ Run Evolution'}
                    </button>
                  </div>

                  {/* Evolution Stats */}
                  <div className="grid grid-cols-2 gap-4">
                    <div className="bg-slate-900/50 rounded-xl p-4">
                      <div className="text-xs text-slate-500">Generation</div>
                      <div className="text-3xl font-bold text-purple-400">{evolverStats.generation}</div>
                    </div>
                    <div className="bg-slate-900/50 rounded-xl p-4">
                      <div className="text-xs text-slate-500">Best Fitness</div>
                      <div className={`text-3xl font-bold ${evolverStats.bestFitness >= 0 ? 'text-emerald-400' : 'text-red-400'}`}>
                        {evolverStats.bestFitness.toFixed(1)}%
                      </div>
                    </div>
                  </div>

                  {/* Current Population */}
                  <div className="bg-slate-900/50 rounded-xl p-4">
                    <div className="text-sm text-slate-400 mb-3">Population (Top 5)</div>
                    <div className="space-y-2">
                      {evolverRef.current.population.slice(0, 5).map((ind, i) => (
                        <div key={i} className={`flex items-center justify-between p-2 rounded-lg ${i === 0 ? 'bg-purple-500/20 border border-purple-500/30' : 'bg-slate-800/50'}`}>
                          <div className="flex items-center gap-4 text-sm">
                            <span className="text-cyan-400 font-bold">#{i + 1}</span>
                            <span>SL: {ind.stopLoss.toFixed(1)}%</span>
                            <span>TP: {ind.takeProfit.toFixed(1)}%</span>
                            <span>Size: {ind.tradeSize.toFixed(0)}%</span>
                            <span>RSI: {ind.rsiOversold.toFixed(0)}/{ind.rsiOverbought.toFixed(0)}</span>
                          </div>
                          <div className="flex items-center gap-2">
                            <span className={`font-mono ${ind.fitness >= 0 ? 'text-emerald-400' : 'text-red-400'}`}>
                              {ind.fitness?.toFixed(1) || '?'}%
                            </span>
                            {i === 0 && (
                              <button
                                onClick={() => {
                                  setSettings(s => ({
                                    ...s,
                                    stopLoss: ind.stopLoss,
                                    takeProfit: ind.takeProfit,
                                    tradeSize: ind.tradeSize
                                  }));
                                  addLog(`Applied best evolved params: SL ${ind.stopLoss.toFixed(1)}%, TP ${ind.takeProfit.toFixed(1)}%`, 'success');
                                }}
                                className="px-2 py-1 bg-cyan-500/20 text-cyan-400 rounded text-xs hover:bg-cyan-500/30"
                              >
                                Apply
                              </button>
                            )}
                          </div>
                        </div>
                      ))}
                    </div>
                  </div>

                  {/* Best Ever */}
                  {evolverRef.current.bestEver && (
                    <div className="bg-gradient-to-r from-purple-500/20 to-pink-500/20 rounded-xl p-4 border border-purple-500/30">
                      <div className="text-sm text-slate-400 mb-2">ðŸ† Best Ever Configuration</div>
                      <div className="flex items-center justify-between">
                        <div className="flex gap-4 text-sm">
                          <span>SL: <span className="text-cyan-400">{evolverRef.current.bestEver.stopLoss.toFixed(1)}%</span></span>
                          <span>TP: <span className="text-cyan-400">{evolverRef.current.bestEver.takeProfit.toFixed(1)}%</span></span>
                          <span>Size: <span className="text-cyan-400">{evolverRef.current.bestEver.tradeSize.toFixed(0)}%</span></span>
                        </div>
                        <div className={`text-xl font-bold ${evolverRef.current.bestEver.fitness >= 0 ? 'text-emerald-400' : 'text-red-400'}`}>
                          {evolverRef.current.bestEver.fitness.toFixed(1)}%
                        </div>
                      </div>
                    </div>
                  )}

                  {/* Performance Stats */}
                  <div className="bg-slate-900/50 rounded-xl p-4">
                    <div className="text-sm text-slate-400 mb-3">Performance Metrics</div>
                    <div className="grid grid-cols-3 gap-4 text-center">
                      <div>
                        <div className="text-xl font-bold text-cyan-400">{perfTrackerRef.current.getWinRate().toFixed(0)}%</div>
                        <div className="text-xs text-slate-500">Win Rate</div>
                      </div>
                      <div>
                        <div className="text-xl font-bold text-purple-400">{perfTrackerRef.current.getSharpeRatio().toFixed(2)}</div>
                        <div className="text-xs text-slate-500">Sharpe Ratio</div>
                      </div>
                      <div>
                        <div className="text-xl font-bold text-red-400">{perfTrackerRef.current.getMaxDrawdown().toFixed(1)}%</div>
                        <div className="text-xs text-slate-500">Max Drawdown</div>
                      </div>
                    </div>
                  </div>
                </div>
              )}

              {/* Pro Strategies Tab (Legendary Trader Rules) */}
              {activeTab === 'pro' && (
                <div className="space-y-4">
                  <div className="flex items-center justify-between">
                    <div>
                      <div className="font-semibold">ðŸ† Pro Strategies</div>
                      <div className="text-sm text-slate-400">Legendary trader rules for maximum profit growth</div>
                    </div>
                    <label className="flex items-center gap-2 cursor-pointer">
                      <input type="checkbox" checked={proStrategiesEnabled} onChange={e => setProStrategiesEnabled(e.target.checked)} className="rounded" />
                      <span className="text-sm">Enable Pro Rules</span>
                    </label>
                  </div>

                  {/* Kelly Criterion Position Sizing */}
                  <div className="bg-slate-900/50 rounded-xl p-4">
                    <div className="text-sm text-slate-400 mb-2">ðŸ“ Kelly Criterion Position Sizing</div>
                    <div className="flex items-center justify-between">
                      <div>
                        <div className="text-xs text-slate-500">Mathematically optimal bet sizing for geometric growth</div>
                        <div className="mt-2 flex items-center gap-4">
                          <label className="flex items-center gap-2 text-sm">
                            <span className="text-slate-400">Kelly Fraction:</span>
                            <select
                              value={proStrategySettings.kellyFraction}
                              onChange={e => setProStrategySettings(s => ({ ...s, kellyFraction: parseFloat(e.target.value) }))}
                              className="bg-slate-800 rounded px-2 py-1 text-sm"
                            >
                              <option value="0.25">Quarter Kelly (0.25)</option>
                              <option value="0.5">Half Kelly (0.5) - Recommended</option>
                              <option value="0.75">Three-Quarter Kelly (0.75)</option>
                              <option value="1.0">Full Kelly (1.0) - Aggressive</option>
                            </select>
                          </label>
                        </div>
                      </div>
                      <div className="text-right">
                        <div className="text-2xl font-bold text-amber-400">
                          {(proStrategyStats.kellySize * 100).toFixed(1)}%
                        </div>
                        <div className="text-xs text-slate-500">Suggested Position Size</div>
                      </div>
                    </div>
                  </div>

                  {/* 200-Day MA Filter (Paul Tudor Jones) */}
                  <div className="bg-slate-900/50 rounded-xl p-4">
                    <div className="flex items-center justify-between">
                      <div>
                        <div className="text-sm text-slate-400 mb-1">ðŸ“‰ 200-Day MA Filter <span className="text-xs text-cyan-400">(Paul Tudor Jones)</span></div>
                        <div className="text-xs text-slate-500">Never be long below the 200-day moving average</div>
                      </div>
                      <label className="flex items-center gap-2 cursor-pointer">
                        <input
                          type="checkbox"
                          checked={proStrategySettings.ma200FilterEnabled}
                          onChange={e => setProStrategySettings(s => ({ ...s, ma200FilterEnabled: e.target.checked }))}
                          className="rounded"
                        />
                        <span className="text-xs">Enabled</span>
                      </label>
                    </div>
                    <div className="mt-3 flex items-center justify-between">
                      <div className={`px-3 py-1 rounded-full text-sm font-medium ${proStrategyStats.ma200Status.aboveMA ? 'bg-emerald-500/20 text-emerald-400' : 'bg-red-500/20 text-red-400'}`}>
                        {proStrategyStats.ma200Status.aboveMA ? 'âœ“ Above 200 MA - Longs Allowed' : 'âš ï¸ Below 200 MA - Exit Longs'}
                      </div>
                      <div className="text-sm text-slate-400">
                        Distance: <span className={proStrategyStats.ma200Status.distance >= 0 ? 'text-emerald-400' : 'text-red-400'}>
                          {proStrategyStats.ma200Status.distance >= 0 ? '+' : ''}{proStrategyStats.ma200Status.distance.toFixed(2)}%
                        </span>
                      </div>
                    </div>
                  </div>

                  {/* Pyramiding System (Jesse Livermore) */}
                  <div className="bg-slate-900/50 rounded-xl p-4">
                    <div className="flex items-center justify-between">
                      <div>
                        <div className="text-sm text-slate-400 mb-1">ðŸ”º Pyramiding System <span className="text-xs text-cyan-400">(Jesse Livermore)</span></div>
                        <div className="text-xs text-slate-500">Add to winning positions at +2%, +4%, +6%</div>
                      </div>
                      <label className="flex items-center gap-2 cursor-pointer">
                        <input
                          type="checkbox"
                          checked={proStrategySettings.pyramidingEnabled}
                          onChange={e => setProStrategySettings(s => ({ ...s, pyramidingEnabled: e.target.checked }))}
                          className="rounded"
                        />
                        <span className="text-xs">Enabled</span>
                      </label>
                    </div>
                    <div className="mt-3 grid grid-cols-4 gap-2">
                      {[0, 1, 2, 3].map(level => (
                        <div key={level} className={`text-center p-2 rounded-lg ${proStrategyStats.pyramidLevel > level ? 'bg-emerald-500/20 border border-emerald-500/30' : 'bg-slate-800/50'}`}>
                          <div className="text-xs text-slate-400">{level === 0 ? 'Entry' : `+${level * 2}%`}</div>
                          <div className="text-sm font-bold">{level === 0 ? '25%' : '25%'}</div>
                        </div>
                      ))}
                    </div>
                  </div>

                  {/* Asymmetric Risk/Reward (George Soros) */}
                  <div className="bg-slate-900/50 rounded-xl p-4">
                    <div className="flex items-center justify-between">
                      <div>
                        <div className="text-sm text-slate-400 mb-1">âš–ï¸ Asymmetric Risk Filter <span className="text-xs text-cyan-400">(George Soros)</span></div>
                        <div className="text-xs text-slate-500">Only trade when risk/reward is heavily skewed</div>
                      </div>
                      <div className="flex items-center gap-3">
                        <label className="flex items-center gap-2 text-sm">
                          <span className="text-xs text-slate-400">Min R:R</span>
                          <select
                            value={proStrategySettings.minRiskReward}
                            onChange={e => setProStrategySettings(s => ({ ...s, minRiskReward: parseFloat(e.target.value) }))}
                            className="bg-slate-800 rounded px-2 py-1 text-xs"
                          >
                            <option value="2">2:1</option>
                            <option value="3">3:1 (Recommended)</option>
                            <option value="5">5:1 (Conservative)</option>
                          </select>
                        </label>
                      </div>
                    </div>
                    <div className="mt-3">
                      <div className="flex items-center justify-between">
                        <span className="text-sm text-slate-400">Current R:R Ratio:</span>
                        <span className={`text-lg font-bold ${proStrategyStats.riskRewardRatio >= proStrategySettings.minRiskReward ? 'text-emerald-400' : 'text-amber-400'}`}>
                          {proStrategyStats.riskRewardRatio.toFixed(1)}:1
                        </span>
                      </div>
                    </div>
                  </div>

                  {/* Seykota Stop Loss Rule */}
                  <div className="bg-slate-900/50 rounded-xl p-4">
                    <div className="flex items-center justify-between">
                      <div>
                        <div className="text-sm text-slate-400 mb-1">âœ‚ï¸ 2% Maximum Loss <span className="text-xs text-cyan-400">(Ed Seykota)</span></div>
                        <div className="text-xs text-slate-500">"Cut losses, cut losses, cut losses" - No exceptions</div>
                      </div>
                      <label className="flex items-center gap-2 cursor-pointer">
                        <input
                          type="checkbox"
                          checked={proStrategySettings.seykotaStopEnabled}
                          onChange={e => setProStrategySettings(s => ({ ...s, seykotaStopEnabled: e.target.checked }))}
                          className="rounded"
                        />
                        <span className="text-xs">Enforced</span>
                      </label>
                    </div>
                  </div>

                  {/* Rules Check Summary */}
                  <div className="bg-gradient-to-r from-amber-500/10 to-orange-500/10 rounded-xl p-4 border border-amber-500/30">
                    <div className="text-sm text-slate-400 mb-2">ðŸ“‹ Rules Check</div>
                    {proStrategyStats.rulesCheck.violations.length > 0 && (
                      <div className="space-y-1 mb-2">
                        {proStrategyStats.rulesCheck.violations.map((v, i) => (
                          <div key={i} className="text-xs text-red-400">âŒ {v}</div>
                        ))}
                      </div>
                    )}
                    {proStrategyStats.rulesCheck.recommendations.length > 0 && (
                      <div className="space-y-1">
                        {proStrategyStats.rulesCheck.recommendations.slice(0, 3).map((r, i) => (
                          <div key={i} className="text-xs text-emerald-400">âœ“ {r}</div>
                        ))}
                      </div>
                    )}
                    {proStrategyStats.rulesCheck.violations.length === 0 && proStrategyStats.rulesCheck.recommendations.length === 0 && (
                      <div className="text-xs text-slate-500">Fetch historical data to analyze</div>
                    )}
                  </div>
                </div>
              )}

              {/* Market Structure Tab */}
              {activeTab === 'market' && (
                <div className="space-y-4">
                  <div className="flex items-center justify-between">
                    <div>
                      <div className="font-semibold">ðŸ“Š Market Structure</div>
                      <div className="text-sm text-slate-400">Advanced signals from Turtle Trading, VCP, & Fear/Greed</div>
                    </div>
                  </div>

                  {/* Turtle Trading Signals */}
                  <div className="bg-slate-900/50 rounded-xl p-4">
                    <div className="text-sm text-slate-400 mb-2">ðŸ¢ Turtle Trading System</div>
                    <div className="text-xs text-slate-500 mb-3">Richard Dennis's legendary trend-following system</div>
                    <div className="grid grid-cols-2 gap-4">
                      <div>
                        <div className="text-xs text-slate-500">Signal</div>
                        <div className={`text-lg font-bold ${proStrategyStats.turtleSignal === 'STRONG_BUY' ? 'text-emerald-400' : proStrategyStats.turtleSignal === 'BUY' ? 'text-green-400' : proStrategyStats.turtleSignal === 'EXIT' ? 'text-red-400' : 'text-slate-400'}`}>
                          {proStrategyStats.turtleSignal || 'NONE'}
                        </div>
                      </div>
                      <div>
                        <div className="text-xs text-slate-500">20-Day High</div>
                        <div className="text-lg font-mono text-cyan-400">
                          ${proStrategyStats.turtleHigh20 ? formatPrice(proStrategyStats.turtleHigh20, selectedPair) : '-'}
                        </div>
                      </div>
                    </div>
                    <div className="mt-3 grid grid-cols-3 gap-2 text-center">
                      <div className="bg-slate-800/50 rounded p-2">
                        <div className="text-xs text-slate-500">ATR</div>
                        <div className="text-sm font-mono">{proStrategyStats.turtleATR?.toFixed(2) || '-'}</div>
                      </div>
                      <div className="bg-slate-800/50 rounded p-2">
                        <div className="text-xs text-slate-500">Unit Size</div>
                        <div className="text-sm font-mono">{proStrategyStats.turtleUnitSize ? (proStrategyStats.turtleUnitSize * 100).toFixed(1) + '%' : '-'}</div>
                      </div>
                      <div className="bg-slate-800/50 rounded p-2">
                        <div className="text-xs text-slate-500">Stop Level</div>
                        <div className="text-sm font-mono text-red-400">${proStrategyStats.turtleStop ? formatPrice(proStrategyStats.turtleStop, selectedPair) : '-'}</div>
                      </div>
                    </div>
                  </div>

                  {/* VCP Pattern (Mark Minervini) */}
                  <div className="bg-slate-900/50 rounded-xl p-4">
                    <div className="text-sm text-slate-400 mb-2">ðŸ“ˆ Volatility Contraction Pattern <span className="text-xs text-cyan-400">(Mark Minervini)</span></div>
                    <div className="flex items-center justify-between">
                      <div>
                        <div className={`px-3 py-1 rounded-full text-sm font-medium ${proStrategyStats.vcpDetected ? 'bg-emerald-500/20 text-emerald-400' : 'bg-slate-700 text-slate-400'}`}>
                          {proStrategyStats.vcpDetected ? 'âœ“ VCP Detected - Entry Setup!' : 'No VCP Pattern'}
                        </div>
                        {proStrategyStats.vcpBreakout && (
                          <div className="mt-2 text-sm">
                            Breakout Level: <span className="text-cyan-400 font-mono">${formatPrice(proStrategyStats.vcpBreakout, selectedPair)}</span>
                          </div>
                        )}
                      </div>
                      <div className="text-right">
                        <div className="text-xs text-slate-500">Confidence</div>
                        <div className="text-xl font-bold text-purple-400">{((proStrategyStats.vcpConfidence || 0) * 100).toFixed(0)}%</div>
                      </div>
                    </div>
                  </div>

                  {/* Fear & Greed Gauge */}
                  <div className="bg-slate-900/50 rounded-xl p-4">
                    <div className="flex items-center justify-between mb-2">
                      <div className="text-sm text-slate-400">ðŸ˜± Fear & Greed Index</div>
                      <button
                        onClick={updateFearGreed}
                        className="px-3 py-1 bg-amber-500/20 text-amber-400 border border-amber-500/30 rounded-lg text-xs hover:bg-amber-500/30 transition"
                      >
                        ðŸ”„ Refresh Live
                      </button>
                    </div>
                    <div className="text-xs text-slate-500 mb-3">Buy extreme fear, sell extreme greed {socialSentiment.fear_greed_label && `â€¢ Current: ${socialSentiment.fear_greed_label}`}</div>
                    <div className="relative h-8 bg-gradient-to-r from-red-500 via-amber-500 to-emerald-500 rounded-full overflow-hidden">
                      <div
                        className="absolute top-0 bottom-0 w-1 bg-white shadow-lg"
                        style={{ left: `${proStrategyStats.fearGreedScore || 50}%`, transform: 'translateX(-50%)' }}
                      />
                    </div>
                    <div className="flex justify-between text-xs text-slate-400 mt-1">
                      <span>Extreme Fear (0)</span>
                      <span>Neutral (50)</span>
                      <span>Extreme Greed (100)</span>
                    </div>
                    <div className="mt-3 flex items-center justify-between">
                      <div className={`px-3 py-1 rounded-full text-sm font-medium ${
                        proStrategyStats.fearGreedScore <= 20 ? 'bg-emerald-500/20 text-emerald-400' :
                        proStrategyStats.fearGreedScore >= 80 ? 'bg-red-500/20 text-red-400' :
                        'bg-slate-700 text-slate-400'
                      }`}>
                        {proStrategyStats.fearGreedLabel || 'Neutral'}
                      </div>
                      <div className="text-2xl font-bold">{proStrategyStats.fearGreedScore?.toFixed(0) || 50}</div>
                    </div>
                    {proStrategyStats.fearGreedSignal && proStrategyStats.fearGreedSignal !== 'HOLD' && (
                      <div className={`mt-2 text-sm ${proStrategyStats.fearGreedSignal.includes('BUY') ? 'text-emerald-400' : 'text-amber-400'}`}>
                        Signal: {proStrategyStats.fearGreedSignal}
                      </div>
                    )}
                  </div>

                  {/* Compound Interest Stats */}
                  <div className="bg-slate-900/50 rounded-xl p-4">
                    <div className="text-sm text-slate-400 mb-2">ðŸ’° Compound Growth Optimizer</div>
                    <div className="grid grid-cols-3 gap-4 text-center">
                      <div>
                        <div className="text-xs text-slate-500">Trading Capital</div>
                        <div className="text-xl font-bold text-cyan-400">${compoundOptimizerRef.current.tradingCapital.toFixed(2)}</div>
                      </div>
                      <div>
                        <div className="text-xs text-slate-500">Profit Reserve</div>
                        <div className="text-xl font-bold text-emerald-400">${compoundOptimizerRef.current.profitReserve.toFixed(2)}</div>
                      </div>
                      <div>
                        <div className="text-xs text-slate-500">Total Return</div>
                        <div className={`text-xl font-bold ${compoundOptimizerRef.current.getStats().totalReturn >= 0 ? 'text-emerald-400' : 'text-red-400'}`}>
                          {compoundOptimizerRef.current.getStats().totalReturn.toFixed(1)}%
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              )}

              {/* Risk Management Tab */}
              {activeTab === 'risk' && (
                <div className="space-y-4">
                  <div className="flex items-center justify-between">
                    <div>
                      <div className="font-semibold">ðŸ›¡ï¸ Risk Management Dashboard</div>
                      <div className="text-sm text-slate-400">Advanced protection systems and position monitoring</div>
                    </div>
                    <button
                      onClick={() => exportTradesToCSV(trades)}
                      className="bg-cyan-500/20 text-cyan-400 border border-cyan-500/30 px-3 py-1.5 rounded-lg text-sm hover:bg-cyan-500/30"
                    >
                      ðŸ“¥ Export Trades CSV
                    </button>
                  </div>

                  {/* Trading Status Banner */}
                  {riskManagement.tradingPaused && (
                    <div className="bg-red-500/20 border border-red-500/50 rounded-xl p-4 flex items-center justify-between">
                      <div>
                        <div className="font-bold text-red-400">âš ï¸ TRADING PAUSED</div>
                        <div className="text-sm text-red-300">{riskManagement.pauseReason}</div>
                        {riskManagement.cooldownUntil && (
                          <div className="text-xs text-slate-400 mt-1">Cooldown until: {new Date(riskManagement.cooldownUntil).toLocaleTimeString()}</div>
                        )}
                      </div>
                      <button
                        onClick={() => setRiskManagement(r => ({ ...r, tradingPaused: false, cooldownUntil: null, pauseReason: '', consecutiveLosses: 0 }))}
                        className="bg-emerald-500/20 text-emerald-400 border border-emerald-500/30 px-3 py-1.5 rounded-lg text-sm"
                      >
                        Resume Trading
                      </button>
                    </div>
                  )}

                  {/* Daily P&L and Circuit Breaker */}
                  <div className="grid grid-cols-2 md:grid-cols-4 gap-3">
                    <div className="bg-slate-900/50 rounded-xl p-4">
                      <div className="text-xs text-slate-500">Daily P&L</div>
                      <div className={`text-xl font-bold ${riskManagement.dailyPnL >= 0 ? 'text-emerald-400' : 'text-red-400'}`}>
                        {riskManagement.dailyPnL >= 0 ? '+' : ''}{((balance - riskManagement.dailyStartBalance) / riskManagement.dailyStartBalance * 100).toFixed(2)}%
                      </div>
                      <div className="text-xs text-slate-500 mt-1">Limit: -{(riskManagement.dailyLossLimit * 100).toFixed(0)}%</div>
                    </div>
                    <div className="bg-slate-900/50 rounded-xl p-4">
                      <div className="text-xs text-slate-500">Consecutive Losses</div>
                      <div className={`text-xl font-bold ${riskManagement.consecutiveLosses >= 2 ? 'text-red-400' : 'text-slate-300'}`}>
                        {riskManagement.consecutiveLosses} / {riskManagement.maxConsecutiveLosses}
                      </div>
                      <div className="text-xs text-slate-500 mt-1">Pause after {riskManagement.maxConsecutiveLosses}</div>
                    </div>
                    <div className="bg-slate-900/50 rounded-xl p-4">
                      <div className="text-xs text-slate-500">Value at Risk (95%)</div>
                      <div className="text-xl font-bold text-amber-400">{riskManagement.var95.toFixed(2)}%</div>
                      <div className="text-xs text-slate-500 mt-1">Daily worst-case</div>
                    </div>
                    <div className="bg-slate-900/50 rounded-xl p-4">
                      <div className="text-xs text-slate-500">Max Drawdown</div>
                      <div className="text-xl font-bold text-red-400">{riskManagement.maxDrawdown.toFixed(2)}%</div>
                      <div className="text-xs text-slate-500 mt-1">Peak to trough</div>
                    </div>
                  </div>

                  {/* Risk Settings */}
                  <div className="bg-slate-900/50 rounded-xl p-4">
                    <div className="text-sm font-medium mb-3">âš™ï¸ Risk Parameters</div>
                    <div className="grid grid-cols-2 md:grid-cols-3 gap-4">
                      <div>
                        <label className="text-xs text-slate-400">Daily Loss Limit (%)</label>
                        <input
                          type="number"
                          value={riskManagement.dailyLossLimit * 100}
                          onChange={e => setRiskManagement(r => ({ ...r, dailyLossLimit: parseFloat(e.target.value) / 100 }))}
                          className="w-full bg-slate-800 rounded px-2 py-1.5 text-sm mt-1"
                          min="1" max="20" step="1"
                        />
                      </div>
                      <div>
                        <label className="text-xs text-slate-400">Max Consecutive Losses</label>
                        <input
                          type="number"
                          value={riskManagement.maxConsecutiveLosses}
                          onChange={e => setRiskManagement(r => ({ ...r, maxConsecutiveLosses: parseInt(e.target.value) }))}
                          className="w-full bg-slate-800 rounded px-2 py-1.5 text-sm mt-1"
                          min="2" max="10" step="1"
                        />
                      </div>
                      <div>
                        <label className="text-xs text-slate-400">Cooldown Minutes</label>
                        <input
                          type="number"
                          value={riskManagement.cooldownMinutes}
                          onChange={e => setRiskManagement(r => ({ ...r, cooldownMinutes: parseInt(e.target.value) }))}
                          className="w-full bg-slate-800 rounded px-2 py-1.5 text-sm mt-1"
                          min="5" max="120" step="5"
                        />
                      </div>
                      <div>
                        <label className="text-xs text-slate-400">Base Slippage (%)</label>
                        <input
                          type="number"
                          value={riskManagement.slippagePercent}
                          onChange={e => setRiskManagement(r => ({ ...r, slippagePercent: parseFloat(e.target.value) }))}
                          className="w-full bg-slate-800 rounded px-2 py-1.5 text-sm mt-1"
                          min="0" max="1" step="0.01"
                        />
                      </div>
                      <div>
                        <label className="text-xs text-slate-400">Max Open Positions</label>
                        <input
                          type="number"
                          value={riskManagement.maxOpenPositions}
                          onChange={e => setRiskManagement(r => ({ ...r, maxOpenPositions: parseInt(e.target.value) }))}
                          className="w-full bg-slate-800 rounded px-2 py-1.5 text-sm mt-1"
                          min="1" max="20" step="1"
                        />
                      </div>
                      <div>
                        <label className="text-xs text-slate-400">Max Correlated (%)</label>
                        <input
                          type="number"
                          value={riskManagement.maxCorrelatedExposure * 100}
                          onChange={e => setRiskManagement(r => ({ ...r, maxCorrelatedExposure: parseFloat(e.target.value) / 100 }))}
                          className="w-full bg-slate-800 rounded px-2 py-1.5 text-sm mt-1"
                          min="10" max="80" step="5"
                        />
                      </div>
                    </div>
                  </div>

                  {/* Position Exposure */}
                  <div className="bg-slate-900/50 rounded-xl p-4">
                    <div className="text-sm font-medium mb-3">ðŸ“Š Position Exposure</div>
                    <div className="space-y-2">
                      {Object.keys(positions).length === 0 ? (
                        <div className="text-slate-500 text-sm">No open positions</div>
                      ) : (
                        Object.entries(positions).map(([pair, pos]) => {
                          const currentPrice = prices[pair] || BASE_PRICES[pair];
                          const pnl = (currentPrice - pos.entryPrice) / pos.entryPrice * 100;
                          return (
                            <div key={pair} className="flex items-center justify-between bg-slate-800/50 rounded-lg p-2">
                              <div className="flex items-center gap-3">
                                <span className="font-medium">{pair}</span>
                                <span className={`text-xs px-2 py-0.5 rounded ${pos.side === 'buy' ? 'bg-emerald-500/20 text-emerald-400' : 'bg-red-500/20 text-red-400'}`}>
                                  {pos.side?.toUpperCase()}
                                </span>
                              </div>
                              <div className="flex items-center gap-4 text-sm">
                                <span className="text-slate-400">Size: ${pos.amount?.toFixed(2)}</span>
                                <span className={pnl >= 0 ? 'text-emerald-400' : 'text-red-400'}>
                                  {pnl >= 0 ? '+' : ''}{pnl.toFixed(2)}%
                                </span>
                                <span className="text-slate-500">
                                  Exposure: {((pos.amount / balance) * 100).toFixed(1)}%
                                </span>
                              </div>
                            </div>
                          );
                        })
                      )}
                    </div>
                    <div className="mt-3 pt-3 border-t border-slate-700 flex justify-between text-sm">
                      <span className="text-slate-400">Total Exposure:</span>
                      <span className="font-medium">
                        {(Object.values(positions).reduce((sum, p) => sum + (p.amount || 0), 0) / balance * 100).toFixed(1)}%
                      </span>
                    </div>
                  </div>

                  {/* Notification Settings */}
                  <div className="bg-slate-900/50 rounded-xl p-4">
                    <div className="text-sm font-medium mb-3">ðŸ”” Notifications</div>
                    <div className="flex flex-wrap gap-4">
                      <label className="flex items-center gap-2 cursor-pointer">
                        <input
                          type="checkbox"
                          checked={notifications.desktopEnabled}
                          onChange={e => {
                            setNotifications(n => ({ ...n, desktopEnabled: e.target.checked }));
                            if (e.target.checked && 'Notification' in window) {
                              Notification.requestPermission();
                            }
                          }}
                          className="rounded"
                        />
                        <span className="text-sm">Desktop Notifications</span>
                      </label>
                      <label className="flex items-center gap-2 cursor-pointer">
                        <input
                          type="checkbox"
                          checked={notifications.soundEnabled}
                          onChange={e => setNotifications(n => ({ ...n, soundEnabled: e.target.checked }))}
                          className="rounded"
                        />
                        <span className="text-sm">Sound Alerts</span>
                      </label>
                      <label className="flex items-center gap-2 cursor-pointer">
                        <input
                          type="checkbox"
                          checked={notifications.criticalAlertsOnly}
                          onChange={e => setNotifications(n => ({ ...n, criticalAlertsOnly: e.target.checked }))}
                          className="rounded"
                        />
                        <span className="text-sm">Critical Only</span>
                      </label>
                      <button
                        onClick={() => sendNotification('Test Alert', 'Notifications are working!', 'success')}
                        className="text-xs bg-slate-700 px-2 py-1 rounded hover:bg-slate-600"
                      >
                        Test Alert
                      </button>
                    </div>
                  </div>
                </div>
              )}

              {/* Trades Tab */}
              {activeTab === 'trades' && (
                <div className="h-64 overflow-y-auto">
                  {trades.length === 0 ? (
                    <div className="text-center text-slate-500 py-8">No trades yet</div>
                  ) : (
                    <table className="w-full text-sm">
                      <thead className="text-slate-500 text-xs sticky top-0 bg-slate-800/90">
                        <tr>
                          <th className="text-left pb-2">Time</th>
                          <th className="text-left">Side</th>
                          <th className="text-left">Pair</th>
                          <th className="text-right">Price</th>
                          <th className="text-right">P&L</th>
                        </tr>
                      </thead>
                      <tbody>
                        {trades.slice().reverse().slice(0, 30).map((t, i) => (
                          <tr key={i} className="border-t border-slate-700/30">
                            <td className="py-1.5 text-slate-400 text-xs">{new Date(t.time).toLocaleTimeString()}</td>
                            <td>
                              <span className={`px-1.5 py-0.5 rounded text-xs font-bold ${t.side === 'BUY' ? 'bg-emerald-500/20 text-emerald-400' : 'bg-red-500/20 text-red-400'}`}>
                                {t.side}
                              </span>
                            </td>
                            <td className="text-xs">{t.pair}</td>
                            <td className="text-right font-mono text-xs">${formatPrice(t.price, t.pair)}</td>
                            <td className={`text-right font-mono text-xs ${t.pnl !== undefined ? (t.pnl >= 0 ? 'text-emerald-400' : 'text-red-400') : 'text-slate-500'}`}>
                              {t.pnl !== undefined ? `${t.pnl >= 0 ? '+' : ''}$${t.pnl.toFixed(2)}` : '-'}
                            </td>
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  )}
                </div>
              )}

              {/* Equity Tab */}
              {activeTab === 'equity' && (
                <div>
                  <div className="text-sm text-slate-400 mb-4">Portfolio Equity Curve</div>
                  <div className="h-48">
                    {equityCurve.length > 1 ? (
                      <svg viewBox="0 0 400 150" className="w-full h-full">
                        {(() => {
                          const values = equityCurve.map(e => e.equity);
                          const min = Math.min(...values);
                          const max = Math.max(...values);
                          const range = max - min || 1;
                          const points = equityCurve.map((e, i) => {
                            const x = (i / (equityCurve.length - 1)) * 400;
                            const y = 140 - ((e.equity - min) / range) * 130;
                            return `${x},${y}`;
                          }).join(' ');
                          const startY = 140 - ((initialBalance - min) / range) * 130;
                          return (
                            <>
                              <defs>
                                <linearGradient id="eqGradient" x1="0" y1="0" x2="0" y2="1">
                                  <stop offset="0%" stopColor="rgb(16, 185, 129)" stopOpacity="0.3"/>
                                  <stop offset="100%" stopColor="rgb(16, 185, 129)" stopOpacity="0"/>
                                </linearGradient>
                              </defs>
                              <line x1="0" y1={startY} x2="400" y2={startY} stroke="rgba(100,116,139,0.5)" strokeDasharray="4"/>
                              <polygon points={`0,150 ${points} 400,150`} fill="url(#eqGradient)"/>
                              <polyline points={points} fill="none" stroke="rgb(16, 185, 129)" strokeWidth="2"/>
                            </>
                          );
                        })()}
                      </svg>
                    ) : (
                      <div className="flex items-center justify-center h-full text-slate-500">Collecting data...</div>
                    )}
                  </div>
                  <div className="flex justify-between text-xs text-slate-400 mt-2">
                    <span>Start: ${initialBalance.toFixed(2)}</span>
                    <span>Current: ${balance.toFixed(2)}</span>
                    <span>Change: {formatPercent((balance - initialBalance) / initialBalance * 100)}</span>
                  </div>
                </div>
              )}
            </div>

            {/* Bot Control & Position */}
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              {/* Bot Control */}
              <div className="bg-slate-800/30 backdrop-blur rounded-2xl border border-slate-700/50 p-4">
                <div className="flex items-center justify-between mb-4">
                  <div>
                    <div className="font-semibold">Trading Bot</div>
                    <div className="text-sm text-slate-400">{STRATEGIES[settings.strategy]?.icon} {STRATEGIES[settings.strategy]?.name} â€¢ {selectedPair}</div>
                  </div>
                  <div className={`w-4 h-4 rounded-full ${isRunning ? 'bg-emerald-400 animate-pulse' : 'bg-slate-600'}`}></div>
                </div>
                <button
                  onClick={toggleBot}
                  className={`w-full py-4 rounded-xl font-bold text-lg transition ${isRunning ? 'bg-gradient-to-r from-red-500 to-orange-500 hover:from-red-600 hover:to-orange-600' : 'bg-gradient-to-r from-emerald-500 to-cyan-500 hover:from-emerald-600 hover:to-cyan-600'}`}
                >
                  {isRunning ? 'â–  Stop Bot' : 'â–¶ Start Bot'}
                </button>
              </div>

              {/* Position */}
              <div className="bg-slate-800/30 backdrop-blur rounded-2xl border border-slate-700/50 p-4">
                <div className="font-semibold mb-3">Position</div>
                {positions[selectedPair] ? (
                  <div className="space-y-2 text-sm">
                    <div className="flex justify-between">
                      <span className="text-slate-400">Entry</span>
                      <span className="font-mono">${formatPrice(positions[selectedPair].entry, selectedPair)}</span>
                    </div>
                    <div className="flex justify-between">
                      <span className="text-slate-400">Size</span>
                      <span className="font-mono">{positions[selectedPair].quantity.toFixed(6)}</span>
                    </div>
                    <div className="flex justify-between">
                      <span className="text-slate-400">P&L</span>
                      <span className={`font-mono font-bold ${(positions[selectedPair].quantity * currentPrice - positions[selectedPair].cost) >= 0 ? 'text-emerald-400' : 'text-red-400'}`}>
                        ${(positions[selectedPair].quantity * currentPrice - positions[selectedPair].cost).toFixed(2)}
                      </span>
                    </div>
                    <button
                      onClick={() => executeTrade('sell', selectedPair, 'Manual Close')}
                      className="w-full py-2 rounded-xl bg-red-500/20 text-red-400 border border-red-500/30 text-sm font-medium hover:bg-red-500/30 transition"
                    >
                      Close Position
                    </button>
                  </div>
                ) : (
                  <div className="text-slate-500 text-center py-6">No open position</div>
                )}
              </div>
            </div>

            {/* Activity Log */}
            <div className="bg-slate-800/30 backdrop-blur rounded-2xl border border-slate-700/50 p-4">
              <div className="text-sm font-medium mb-2">Activity Log</div>
              <div className="h-24 overflow-y-auto font-mono text-xs space-y-0.5">
                {logs.map((l, i) => (
                  <div key={i} className={`${l.type === 'error' ? 'text-red-400' : l.type === 'success' ? 'text-emerald-400' : l.type === 'warning' ? 'text-amber-400' : 'text-slate-400'}`}>
                    <span className="text-slate-600">{l.time}</span> {l.message}
                  </div>
                ))}
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}


        // ==================== RENDER APP ====================
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<KrakenTradingBot />);
    </script>
</body>
</html>